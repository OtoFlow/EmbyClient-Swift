// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
/// Explore the Emby Server API
internal struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    internal init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter {
        client.converter
    }
    /// Gets items based on a query.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Items`.
    /// - Remark: Generated from `#/paths//Items/get(getItems)`.
    internal func getItems(_ input: Operations.getItems.Input) async throws -> Operations.getItems.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItems.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItems.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets release notes
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /System/ReleaseNotes`.
    /// - Remark: Generated from `#/paths//System/ReleaseNotes/get(getSystemReleasenotes)`.
    internal func getSystemReleasenotes(_ input: Operations.getSystemReleasenotes.Input) async throws -> Operations.getSystemReleasenotes.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSystemReleasenotes.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/ReleaseNotes",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSystemReleasenotes.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PackageVersionInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /System/Ping`.
    /// - Remark: Generated from `#/paths//System/Ping/get(getSystemPing)`.
    internal func getSystemPing(_ input: Operations.getSystemPing.Input) async throws -> Operations.getSystemPing.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSystemPing.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/Ping",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /System/Ping`.
    /// - Remark: Generated from `#/paths//System/Ping/post(postSystemPing)`.
    internal func postSystemPing(_ input: Operations.postSystemPing.Input) async throws -> Operations.postSystemPing.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSystemPing.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/Ping",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets wake on lan information
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /System/WakeOnLanInfo`.
    /// - Remark: Generated from `#/paths//System/WakeOnLanInfo/get(getSystemWakeonlaninfo)`.
    internal func getSystemWakeonlaninfo(_ input: Operations.getSystemWakeonlaninfo.Input) async throws -> Operations.getSystemWakeonlaninfo.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSystemWakeonlaninfo.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/WakeOnLanInfo",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSystemWakeonlaninfo.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.WakeOnLanInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets information about the server
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /System/Info`.
    /// - Remark: Generated from `#/paths//System/Info/get(getSystemInfo)`.
    internal func getSystemInfo(_ input: Operations.getSystemInfo.Input) async throws -> Operations.getSystemInfo.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSystemInfo.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/Info",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSystemInfo.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SystemInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Restarts the application, if needed
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /System/Restart`.
    /// - Remark: Generated from `#/paths//System/Restart/post(postSystemRestart)`.
    internal func postSystemRestart(_ input: Operations.postSystemRestart.Input) async throws -> Operations.postSystemRestart.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSystemRestart.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/Restart",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Shuts down the application
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /System/Shutdown`.
    /// - Remark: Generated from `#/paths//System/Shutdown/post(postSystemShutdown)`.
    internal func postSystemShutdown(_ input: Operations.postSystemShutdown.Input) async throws -> Operations.postSystemShutdown.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSystemShutdown.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/Shutdown",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets information about the request endpoint
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /System/Endpoint`.
    /// - Remark: Generated from `#/paths//System/Endpoint/get(getSystemEndpoint)`.
    internal func getSystemEndpoint(_ input: Operations.getSystemEndpoint.Input) async throws -> Operations.getSystemEndpoint.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSystemEndpoint.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/Endpoint",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSystemEndpoint.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Net_period_EndPointInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a list of publicly visible users for display on a login screen.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Users/Public`.
    /// - Remark: Generated from `#/paths//Users/Public/get(getUsersPublic)`.
    internal func getUsersPublic(_ input: Operations.getUsersPublic.Input) async throws -> Operations.getUsersPublic.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUsersPublic.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/Public",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getUsersPublic.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.UserDto].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a list of users
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Users/Query`.
    /// - Remark: Generated from `#/paths//Users/Query/get(getUsersQuery)`.
    internal func getUsersQuery(_ input: Operations.getUsersQuery.Input) async throws -> Operations.getUsersQuery.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUsersQuery.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/Query",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHidden",
                    value: input.query.IsHidden
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsDisabled",
                    value: input.query.IsDisabled
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getUsersQuery.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_UserDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a list of users
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Users/Prefixes`.
    /// - Remark: Generated from `#/paths//Users/Prefixes/get(getUsersPrefixes)`.
    internal func getUsersPrefixes(_ input: Operations.getUsersPrefixes.Input) async throws -> Operations.getUsersPrefixes.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUsersPrefixes.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/Prefixes",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHidden",
                    value: input.query.IsHidden
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsDisabled",
                    value: input.query.IsDisabled
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getUsersPrefixes.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.NameIdPair].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a list of users
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Users/ItemAccess`.
    /// - Remark: Generated from `#/paths//Users/ItemAccess/get(getUsersItemaccess)`.
    internal func getUsersItemaccess(_ input: Operations.getUsersItemaccess.Input) async throws -> Operations.getUsersItemaccess.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUsersItemaccess.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/ItemAccess",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHidden",
                    value: input.query.IsHidden
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsDisabled",
                    value: input.query.IsDisabled
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getUsersItemaccess.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_UserDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a user by Id
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Users/{Id}`.
    /// - Remark: Generated from `#/paths//Users/{Id}/get(getUsersById)`.
    internal func getUsersById(_ input: Operations.getUsersById.Input) async throws -> Operations.getUsersById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUsersById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getUsersById.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates a user
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{Id}`.
    /// - Remark: Generated from `#/paths//Users/{Id}/post(postUsersById)`.
    internal func postUsersById(_ input: Operations.postUsersById.Input) async throws -> Operations.postUsersById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deletes a user
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `DELETE /Users/{Id}`.
    /// - Remark: Generated from `#/paths//Users/{Id}/delete(deleteUsersById)`.
    internal func deleteUsersById(_ input: Operations.deleteUsersById.Input) async throws -> Operations.deleteUsersById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteUsersById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Authenticates a user
    ///
    /// Authenticate a user by nane and password. A 200 status code indicates success, while anything in the 400 or 500 range indicates failure
    /// ---
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/AuthenticateByName`.
    /// - Remark: Generated from `#/paths//Users/AuthenticateByName/post(postUsersAuthenticatebyname)`.
    internal func postUsersAuthenticatebyname(_ input: Operations.postUsersAuthenticatebyname.Input) async throws -> Operations.postUsersAuthenticatebyname.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersAuthenticatebyname.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/AuthenticateByName",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-Emby-Authorization",
                    value: input.headers.X_hyphen_Emby_hyphen_Authorization
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postUsersAuthenticatebyname.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Authentication_period_AuthenticationResult.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Creates a user
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Users/New`.
    /// - Remark: Generated from `#/paths//Users/New/post(postUsersNew)`.
    internal func postUsersNew(_ input: Operations.postUsersNew.Input) async throws -> Operations.postUsersNew.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersNew.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/New",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postUsersNew.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Initiates the forgot password process for a local user
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/ForgotPassword`.
    /// - Remark: Generated from `#/paths//Users/ForgotPassword/post(postUsersForgotpassword)`.
    internal func postUsersForgotpassword(_ input: Operations.postUsersForgotpassword.Input) async throws -> Operations.postUsersForgotpassword.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersForgotpassword.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/ForgotPassword",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postUsersForgotpassword.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ForgotPasswordResult.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets release notes
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /System/ReleaseNotes/Versions`.
    /// - Remark: Generated from `#/paths//System/ReleaseNotes/Versions/get(getSystemReleasenotesVersions)`.
    internal func getSystemReleasenotesVersions(_ input: Operations.getSystemReleasenotesVersions.Input) async throws -> Operations.getSystemReleasenotesVersions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSystemReleasenotesVersions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/ReleaseNotes/Versions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSystemReleasenotesVersions.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.PackageVersionInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a list of available server log files
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /System/Logs/Query`.
    /// - Remark: Generated from `#/paths//System/Logs/Query/get(getSystemLogsQuery)`.
    internal func getSystemLogsQuery(_ input: Operations.getSystemLogsQuery.Input) async throws -> Operations.getSystemLogsQuery.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSystemLogsQuery.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/Logs/Query",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSystemLogsQuery.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_LogFile.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a log file
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /System/Logs/{Name}`.
    /// - Remark: Generated from `#/paths//System/Logs/{Name}/get(getSystemLogsByName)`.
    internal func getSystemLogsByName(_ input: Operations.getSystemLogsByName.Input) async throws -> Operations.getSystemLogsByName.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSystemLogsByName.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/Logs/{}",
                    parameters: [
                        input.path.Name
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Sanitize",
                    value: input.query.Sanitize
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets public information about the server
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /System/Info/Public`.
    /// - Remark: Generated from `#/paths//System/Info/Public/get(getSystemInfoPublic)`.
    internal func getSystemInfoPublic(_ input: Operations.getSystemInfoPublic.Input) async throws -> Operations.getSystemInfoPublic.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSystemInfoPublic.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/Info/Public",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSystemInfoPublic.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PublicSystemInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deletes a user
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Users/{Id}/Delete`.
    /// - Remark: Generated from `#/paths//Users/{Id}/Delete/post(postUsersByIdDelete)`.
    internal func postUsersByIdDelete(_ input: Operations.postUsersByIdDelete.Input) async throws -> Operations.postUsersByIdDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByIdDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Delete",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Authenticates a user
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{Id}/Authenticate`.
    /// - Remark: Generated from `#/paths//Users/{Id}/Authenticate/post(postUsersByIdAuthenticate)`.
    internal func postUsersByIdAuthenticate(_ input: Operations.postUsersByIdAuthenticate.Input) async throws -> Operations.postUsersByIdAuthenticate.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByIdAuthenticate.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Authenticate",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postUsersByIdAuthenticate.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Authentication_period_AuthenticationResult.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates a user's password
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{Id}/Password`.
    /// - Remark: Generated from `#/paths//Users/{Id}/Password/post(postUsersByIdPassword)`.
    internal func postUsersByIdPassword(_ input: Operations.postUsersByIdPassword.Input) async throws -> Operations.postUsersByIdPassword.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByIdPassword.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Password",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Redeems a forgot password pin
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/ForgotPassword/Pin`.
    /// - Remark: Generated from `#/paths//Users/ForgotPassword/Pin/post(postUsersForgotpasswordPin)`.
    internal func postUsersForgotpasswordPin(_ input: Operations.postUsersForgotpasswordPin.Input) async throws -> Operations.postUsersForgotpasswordPin.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersForgotpasswordPin.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/ForgotPassword/Pin",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postUsersForgotpasswordPin.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PinRedeemResult.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates a user configuration
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{Id}/Configuration`.
    /// - Remark: Generated from `#/paths//Users/{Id}/Configuration/post(postUsersByIdConfiguration)`.
    internal func postUsersByIdConfiguration(_ input: Operations.postUsersByIdConfiguration.Input) async throws -> Operations.postUsersByIdConfiguration.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByIdConfiguration.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Configuration",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates a user policy
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Users/{Id}/Policy`.
    /// - Remark: Generated from `#/paths//Users/{Id}/Policy/post(postUsersByIdPolicy)`.
    internal func postUsersByIdPolicy(_ input: Operations.postUsersByIdPolicy.Input) async throws -> Operations.postUsersByIdPolicy.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByIdPolicy.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Policy",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets items based on a query.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Users/{UserId}/Items`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/Items/get(getUsersByUseridItems)`.
    internal func getUsersByUseridItems(_ input: Operations.getUsersByUseridItems.Input) async throws -> Operations.getUsersByUseridItems.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUsersByUseridItems.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Items",
                    parameters: [
                        input.path.UserId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getUsersByUseridItems.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a log file
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /System/Logs/{Name}/Lines`.
    /// - Remark: Generated from `#/paths//System/Logs/{Name}/Lines/get(getSystemLogsByNameLines)`.
    internal func getSystemLogsByNameLines(_ input: Operations.getSystemLogsByNameLines.Input) async throws -> Operations.getSystemLogsByNameLines.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSystemLogsByNameLines.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/Logs/{}/Lines",
                    parameters: [
                        input.path.Name
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSystemLogsByNameLines.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_String.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Clears audio or subtitle track selections for a user
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `DELETE /Users/{Id}/TrackSelections/{TrackType}`.
    /// - Remark: Generated from `#/paths//Users/{Id}/TrackSelections/{TrackType}/delete(deleteUsersByIdTrackselectionsByTracktype)`.
    internal func deleteUsersByIdTrackselectionsByTracktype(_ input: Operations.deleteUsersByIdTrackselectionsByTracktype.Input) async throws -> Operations.deleteUsersByIdTrackselectionsByTracktype.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteUsersByIdTrackselectionsByTracktype.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/TrackSelections/{}",
                    parameters: [
                        input.path.Id,
                        input.path.TrackType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates a user configuration
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{Id}/Configuration/Partial`.
    /// - Remark: Generated from `#/paths//Users/{Id}/Configuration/Partial/post(postUsersByIdConfigurationPartial)`.
    internal func postUsersByIdConfigurationPartial(_ input: Operations.postUsersByIdConfigurationPartial.Input) async throws -> Operations.postUsersByIdConfigurationPartial.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByIdConfigurationPartial.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Configuration/Partial",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .binary(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/octet-stream"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a typed user setting
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Users/{UserId}/TypedSettings/{Key}`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/TypedSettings/{Key}/get(getUsersByUseridTypedsettingsByKey)`.
    internal func getUsersByUseridTypedsettingsByKey(_ input: Operations.getUsersByUseridTypedsettingsByKey.Input) async throws -> Operations.getUsersByUseridTypedsettingsByKey.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUsersByUseridTypedsettingsByKey.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/TypedSettings/{}",
                    parameters: [
                        input.path.UserId,
                        input.path.Key
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates a typed user setting
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{UserId}/TypedSettings/{Key}`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/TypedSettings/{Key}/post(postUsersByUseridTypedsettingsByKey)`.
    internal func postUsersByUseridTypedsettingsByKey(_ input: Operations.postUsersByUseridTypedsettingsByKey.Input) async throws -> Operations.postUsersByUseridTypedsettingsByKey.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByUseridTypedsettingsByKey.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/TypedSettings/{}",
                    parameters: [
                        input.path.UserId,
                        input.path.Key
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .binary(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/octet-stream"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets items based on a query.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Users/{UserId}/Items/Resume`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/Items/Resume/get(getUsersByUseridItemsResume)`.
    internal func getUsersByUseridItemsResume(_ input: Operations.getUsersByUseridItemsResume.Input) async throws -> Operations.getUsersByUseridItemsResume.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUsersByUseridItemsResume.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Items/Resume",
                    parameters: [
                        input.path.UserId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getUsersByUseridItemsResume.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Clears audio or subtitle track selections for a user
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{Id}/TrackSelections/{TrackType}/Delete`.
    /// - Remark: Generated from `#/paths//Users/{Id}/TrackSelections/{TrackType}/Delete/post(postUsersByIdTrackselectionsByTracktypeDelete)`.
    internal func postUsersByIdTrackselectionsByTracktypeDelete(_ input: Operations.postUsersByIdTrackselectionsByTracktypeDelete.Input) async throws -> Operations.postUsersByIdTrackselectionsByTracktypeDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByIdTrackselectionsByTracktypeDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/TrackSelections/{}/Delete",
                    parameters: [
                        input.path.Id,
                        input.path.TrackType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
}
