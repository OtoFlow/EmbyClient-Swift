// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
/// Explore the Emby Server API
internal struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    internal init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter {
        client.converter
    }
    /// Gets all artists from a given item, folder, or the entire library
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Artists`.
    /// - Remark: Generated from `#/paths//Artists/get(getArtists)`.
    internal func getArtists(_ input: Operations.getArtists.Input) async throws -> Operations.getArtists.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getArtists.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Artists",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getArtists.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets items based on a query.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /AudioCodecs`.
    /// - Remark: Generated from `#/paths//AudioCodecs/get(getAudiocodecs)`.
    internal func getAudiocodecs(_ input: Operations.getAudiocodecs.Input) async throws -> Operations.getAudiocodecs.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAudiocodecs.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/AudioCodecs",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAudiocodecs.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_UserLibrary_period_TagItem.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets items based on a query.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /AudioLayouts`.
    /// - Remark: Generated from `#/paths//AudioLayouts/get(getAudiolayouts)`.
    internal func getAudiolayouts(_ input: Operations.getAudiolayouts.Input) async throws -> Operations.getAudiolayouts.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAudiolayouts.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/AudioLayouts",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAudiolayouts.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_UserLibrary_period_TagItem.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets available channels
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Channels`.
    /// - Remark: Generated from `#/paths//Channels/get(getChannels)`.
    internal func getChannels(_ input: Operations.getChannels.Input) async throws -> Operations.getChannels.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getChannels.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Channels",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getChannels.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Creates a new collection
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Collections`.
    /// - Remark: Generated from `#/paths//Collections/post(postCollections)`.
    internal func postCollections(_ input: Operations.postCollections.Input) async throws -> Operations.postCollections.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postCollections.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Name",
                    value: input.query.Name
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postCollections.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Collections_period_CollectionCreationResult.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets items based on a query.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Containers`.
    /// - Remark: Generated from `#/paths//Containers/get(getContainers)`.
    internal func getContainers(_ input: Operations.getContainers.Input) async throws -> Operations.getContainers.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getContainers.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Containers",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getContainers.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_UserLibrary_period_TagItem.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets all devices
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Devices`.
    /// - Remark: Generated from `#/paths//Devices/get(getDevices)`.
    internal func getDevices(_ input: Operations.getDevices.Input) async throws -> Operations.getDevices.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getDevices.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Devices",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getDevices.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_Devices_period_DeviceInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deletes a device
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `DELETE /Devices`.
    /// - Remark: Generated from `#/paths//Devices/delete(deleteDevices)`.
    internal func deleteDevices(_ input: Operations.deleteDevices.Input) async throws -> Operations.deleteDevices.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteDevices.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Devices",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Id",
                    value: input.query.Id
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets items based on a query.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /ExtendedVideoTypes`.
    /// - Remark: Generated from `#/paths//ExtendedVideoTypes/get(getExtendedvideotypes)`.
    internal func getExtendedvideotypes(_ input: Operations.getExtendedvideotypes.Input) async throws -> Operations.getExtendedvideotypes.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getExtendedvideotypes.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/ExtendedVideoTypes",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getExtendedvideotypes.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_UserLibrary_period_TagItem.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a list of installed features
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Features`.
    /// - Remark: Generated from `#/paths//Features/get(getFeatures)`.
    internal func getFeatures(_ input: Operations.getFeatures.Input) async throws -> Operations.getFeatures.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getFeatures.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Features",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getFeatures.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.FeatureInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets all Game genres from a given item, folder, or the entire library
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /GameGenres`.
    /// - Remark: Generated from `#/paths//GameGenres/get(getGamegenres)`.
    internal func getGamegenres(_ input: Operations.getGamegenres.Input) async throws -> Operations.getGamegenres.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getGamegenres.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/GameGenres",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getGamegenres.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets all genres from a given item, folder, or the entire library
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Genres`.
    /// - Remark: Generated from `#/paths//Genres/get(getGenres)`.
    internal func getGenres(_ input: Operations.getGenres.Input) async throws -> Operations.getGenres.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getGenres.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Genres",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getGenres.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets items based on a query.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Items`.
    /// - Remark: Generated from `#/paths//Items/get(getItems)`.
    internal func getItems(_ input: Operations.getItems.Input) async throws -> Operations.getItems.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItems.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItems.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deletes an item from the library and file system
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `DELETE /Items`.
    /// - Remark: Generated from `#/paths//Items/delete(deleteItems)`.
    internal func deleteItems(_ input: Operations.deleteItems.Input) async throws -> Operations.deleteItems.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteItems.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Ids",
                    value: input.query.Ids
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets items based on a query.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /ItemTypes`.
    /// - Remark: Generated from `#/paths//ItemTypes/get(getItemtypes)`.
    internal func getItemtypes(_ input: Operations.getItemtypes.Input) async throws -> Operations.getItemtypes.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemtypes.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/ItemTypes",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItemtypes.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_UserLibrary_period_TagItem.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets all music genres from a given item, folder, or the entire library
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /MusicGenres`.
    /// - Remark: Generated from `#/paths//MusicGenres/get(getMusicgenres)`.
    internal func getMusicgenres(_ input: Operations.getMusicgenres.Input) async throws -> Operations.getMusicgenres.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getMusicgenres.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/MusicGenres",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getMusicgenres.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets items based on a query.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /OfficialRatings`.
    /// - Remark: Generated from `#/paths//OfficialRatings/get(getOfficialratings)`.
    internal func getOfficialratings(_ input: Operations.getOfficialratings.Input) async throws -> Operations.getOfficialratings.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getOfficialratings.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/OfficialRatings",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getOfficialratings.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_UserLibrary_period_OfficialRatingItem.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets the OpenAPI 3 specifications
    ///
    /// No authentication required
    ///
    /// - Remark: HTTP `GET /openapi`.
    /// - Remark: Generated from `#/paths//openapi/get(getOpenapi)`.
    internal func getOpenapi(_ input: Operations.getOpenapi.Input) async throws -> Operations.getOpenapi.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getOpenapi.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/openapi",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getOpenapi.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Swift.String.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets OpenAPI 3 specifications
    ///
    /// No authentication required
    ///
    /// - Remark: HTTP `GET /openapi.json`.
    /// - Remark: Generated from `#/paths//openapi.json/get(getOpenapiJson)`.
    internal func getOpenapiJson(_ input: Operations.getOpenapiJson.Input) async throws -> Operations.getOpenapiJson.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getOpenapiJson.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/openapi.json",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getOpenapiJson.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Swift.String.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets available packages
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Packages`.
    /// - Remark: Generated from `#/paths//Packages/get(getPackages)`.
    internal func getPackages(_ input: Operations.getPackages.Input) async throws -> Operations.getPackages.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getPackages.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Packages",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PackageType",
                    value: input.query.PackageType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "TargetSystems",
                    value: input.query.TargetSystems
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremium",
                    value: input.query.IsPremium
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsAdult",
                    value: input.query.IsAdult
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getPackages.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.PackageInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets all persons from a given item, folder, or the entire library
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Persons`.
    /// - Remark: Generated from `#/paths//Persons/get(getPersons)`.
    internal func getPersons(_ input: Operations.getPersons.Input) async throws -> Operations.getPersons.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getPersons.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Persons",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getPersons.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Creates a new playlist
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Playlists`.
    /// - Remark: Generated from `#/paths//Playlists/post(postPlaylists)`.
    internal func postPlaylists(_ input: Operations.postPlaylists.Input) async throws -> Operations.postPlaylists.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postPlaylists.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Playlists",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Name",
                    value: input.query.Name
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MediaType",
                    value: input.query.MediaType
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postPlaylists.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Playlists_period_PlaylistCreationResult.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a list of currently installed plugins
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Plugins`.
    /// - Remark: Generated from `#/paths//Plugins/get(getPlugins)`.
    internal func getPlugins(_ input: Operations.getPlugins.Input) async throws -> Operations.getPlugins.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getPlugins.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Plugins",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getPlugins.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Plugins_period_PluginInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets scheduled tasks
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /ScheduledTasks`.
    /// - Remark: Generated from `#/paths//ScheduledTasks/get(getScheduledtasks)`.
    internal func getScheduledtasks(_ input: Operations.getScheduledtasks.Input) async throws -> Operations.getScheduledtasks.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getScheduledtasks.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/ScheduledTasks",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHidden",
                    value: input.query.IsHidden
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsEnabled",
                    value: input.query.IsEnabled
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getScheduledtasks.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.TaskInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a list of sessions
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Sessions`.
    /// - Remark: Generated from `#/paths//Sessions/get(getSessions)`.
    internal func getSessions(_ input: Operations.getSessions.Input) async throws -> Operations.getSessions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSessions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sessions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ControllableByUserId",
                    value: input.query.ControllableByUserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Id",
                    value: input.query.Id
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSessions.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Session_period_SessionInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets items based on a query.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /StreamLanguages`.
    /// - Remark: Generated from `#/paths//StreamLanguages/get(getStreamlanguages)`.
    internal func getStreamlanguages(_ input: Operations.getStreamlanguages.Input) async throws -> Operations.getStreamlanguages.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getStreamlanguages.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/StreamLanguages",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getStreamlanguages.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_UserLibrary_period_TagItem.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets all studios from a given item, folder, or the entire library
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Studios`.
    /// - Remark: Generated from `#/paths//Studios/get(getStudios)`.
    internal func getStudios(_ input: Operations.getStudios.Input) async throws -> Operations.getStudios.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getStudios.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Studios",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getStudios.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets items based on a query.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /SubtitleCodecs`.
    /// - Remark: Generated from `#/paths//SubtitleCodecs/get(getSubtitlecodecs)`.
    internal func getSubtitlecodecs(_ input: Operations.getSubtitlecodecs.Input) async throws -> Operations.getSubtitlecodecs.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSubtitlecodecs.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/SubtitleCodecs",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSubtitlecodecs.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_UserLibrary_period_TagItem.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets the swagger specifications
    ///
    /// No authentication required
    ///
    /// - Remark: HTTP `GET /swagger`.
    /// - Remark: Generated from `#/paths//swagger/get(getSwagger)`.
    internal func getSwagger(_ input: Operations.getSwagger.Input) async throws -> Operations.getSwagger.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSwagger.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/swagger",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSwagger.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Swift.String.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets the swagger specifications
    ///
    /// No authentication required
    ///
    /// - Remark: HTTP `GET /swagger.json`.
    /// - Remark: Generated from `#/paths//swagger.json/get(getSwaggerJson)`.
    internal func getSwaggerJson(_ input: Operations.getSwaggerJson.Input) async throws -> Operations.getSwaggerJson.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSwaggerJson.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/swagger.json",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSwaggerJson.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Swift.String.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets items based on a query.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Tags`.
    /// - Remark: Generated from `#/paths//Tags/get(getTags)`.
    internal func getTags(_ input: Operations.getTags.Input) async throws -> Operations.getTags.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getTags.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Tags",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getTags.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_UserLibrary_period_TagItem.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Finds movies and trailers similar to a given trailer.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Trailers`.
    /// - Remark: Generated from `#/paths//Trailers/get(getTrailers)`.
    internal func getTrailers(_ input: Operations.getTrailers.Input) async throws -> Operations.getTrailers.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getTrailers.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Trailers",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getTrailers.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets items based on a query.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /VideoCodecs`.
    /// - Remark: Generated from `#/paths//VideoCodecs/get(getVideocodecs)`.
    internal func getVideocodecs(_ input: Operations.getVideocodecs.Input) async throws -> Operations.getVideocodecs.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getVideocodecs.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/VideoCodecs",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getVideocodecs.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_UserLibrary_period_TagItem.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets items based on a query.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Years`.
    /// - Remark: Generated from `#/paths//Years/get(getYears)`.
    internal func getYears(_ input: Operations.getYears.Input) async throws -> Operations.getYears.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getYears.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Years",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getYears.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_UserLibrary_period_TagItem.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Items/{Id}/Images/{Type}/{Index}/{Tag}/{Format}/{MaxWidth}/{MaxHeight}/{PercentPlayed}/{UnPlayedCount}`.
    /// - Remark: Generated from `#/paths//Items/{Id}/Images/{Type}/{Index}/{Tag}/{Format}/{MaxWidth}/{MaxHeight}/{PercentPlayed}/{UnPlayedCount}/get(getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount)`.
    internal func getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(_ input: Operations.getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.Input) async throws -> Operations.getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/Images/{}/{}/{}/{}/{}/{}/{}/{}",
                    parameters: [
                        input.path.Id,
                        input.path._Type,
                        input.path.Index,
                        input.path.Tag,
                        input.path.Format,
                        input.path.MaxWidth,
                        input.path.MaxHeight,
                        input.path.PercentPlayed,
                        input.path.UnPlayedCount
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Items/{Id}/Images/{Type}/{Index}/{Tag}/{Format}/{MaxWidth}/{MaxHeight}/{PercentPlayed}/{UnPlayedCount}`.
    /// - Remark: Generated from `#/paths//Items/{Id}/Images/{Type}/{Index}/{Tag}/{Format}/{MaxWidth}/{MaxHeight}/{PercentPlayed}/{UnPlayedCount}/head(headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount)`.
    internal func headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(_ input: Operations.headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.Input) async throws -> Operations.headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/Images/{}/{}/{}/{}/{}/{}/{}/{}",
                    parameters: [
                        input.path.Id,
                        input.path._Type,
                        input.path.Index,
                        input.path.Tag,
                        input.path.Format,
                        input.path.MaxWidth,
                        input.path.MaxHeight,
                        input.path.PercentPlayed,
                        input.path.UnPlayedCount
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets an artist, by name
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Artists/{Name}`.
    /// - Remark: Generated from `#/paths//Artists/{Name}/get(getArtistsByName)`.
    internal func getArtistsByName(_ input: Operations.getArtistsByName.Input) async throws -> Operations.getArtistsByName.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getArtistsByName.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Artists/{}",
                    parameters: [
                        input.path.Name
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getArtistsByName.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets all album artists from a given item, folder, or the entire library
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Artists/AlbumArtists`.
    /// - Remark: Generated from `#/paths//Artists/AlbumArtists/get(getArtistsAlbumartists)`.
    internal func getArtistsAlbumartists(_ input: Operations.getArtistsAlbumartists.Input) async throws -> Operations.getArtistsAlbumartists.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getArtistsAlbumartists.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Artists/AlbumArtists",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getArtistsAlbumartists.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets items based on a query.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Artists/Prefixes`.
    /// - Remark: Generated from `#/paths//Artists/Prefixes/get(getArtistsPrefixes)`.
    internal func getArtistsPrefixes(_ input: Operations.getArtistsPrefixes.Input) async throws -> Operations.getArtistsPrefixes.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getArtistsPrefixes.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Artists/Prefixes",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getArtistsPrefixes.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.NameValuePair].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Creates an instant playlist based on a given artist
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Artists/InstantMix`.
    /// - Remark: Generated from `#/paths//Artists/InstantMix/get(getArtistsInstantmix)`.
    internal func getArtistsInstantmix(_ input: Operations.getArtistsInstantmix.Input) async throws -> Operations.getArtistsInstantmix.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getArtistsInstantmix.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Artists/InstantMix",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getArtistsInstantmix.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a list of next up episodes
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /AudioBooks/NextUp`.
    /// - Remark: Generated from `#/paths//AudioBooks/NextUp/get(getAudiobooksNextup)`.
    internal func getAudiobooksNextup(_ input: Operations.getAudiobooksNextup.Input) async throws -> Operations.getAudiobooksNextup.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAudiobooksNextup.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/AudioBooks/NextUp",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumId",
                    value: input.query.AlbumId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAudiobooksNextup.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Auth/Providers`.
    /// - Remark: Generated from `#/paths//Auth/Providers/get(getAuthProviders)`.
    internal func getAuthProviders(_ input: Operations.getAuthProviders.Input) async throws -> Operations.getAuthProviders.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAuthProviders.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Auth/Providers",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAuthProviders.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.NameIdPair].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Auth/Keys`.
    /// - Remark: Generated from `#/paths//Auth/Keys/get(getAuthKeys)`.
    internal func getAuthKeys(_ input: Operations.getAuthKeys.Input) async throws -> Operations.getAuthKeys.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAuthKeys.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Auth/Keys",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Auth/Keys`.
    /// - Remark: Generated from `#/paths//Auth/Keys/post(postAuthKeys)`.
    internal func postAuthKeys(_ input: Operations.postAuthKeys.Input) async throws -> Operations.postAuthKeys.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postAuthKeys.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Auth/Keys",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "App",
                    value: input.query.App
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /BackupRestore/Restore`.
    /// - Remark: Generated from `#/paths//BackupRestore/Restore/post(postBackuprestoreRestore)`.
    internal func postBackuprestoreRestore(_ input: Operations.postBackuprestoreRestore.Input) async throws -> Operations.postBackuprestoreRestore.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postBackuprestoreRestore.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/BackupRestore/Restore",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /BackupRestore/RestoreData`.
    /// - Remark: Generated from `#/paths//BackupRestore/RestoreData/post(postBackuprestoreRestoredata)`.
    internal func postBackuprestoreRestoredata(_ input: Operations.postBackuprestoreRestoredata.Input) async throws -> Operations.postBackuprestoreRestoredata.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postBackuprestoreRestoredata.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/BackupRestore/RestoreData",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /BackupRestore/BackupInfo`.
    /// - Remark: Generated from `#/paths//BackupRestore/BackupInfo/get(getBackuprestoreBackupinfo)`.
    internal func getBackuprestoreBackupinfo(_ input: Operations.getBackuprestoreBackupinfo.Input) async throws -> Operations.getBackuprestoreBackupinfo.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getBackuprestoreBackupinfo.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/BackupRestore/BackupInfo",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getBackuprestoreBackupinfo.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.MBBackup_period_Api_period_AllBackupsInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets branding configuration
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Branding/Configuration`.
    /// - Remark: Generated from `#/paths//Branding/Configuration/get(getBrandingConfiguration)`.
    internal func getBrandingConfiguration(_ input: Operations.getBrandingConfiguration.Input) async throws -> Operations.getBrandingConfiguration.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getBrandingConfiguration.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Branding/Configuration",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getBrandingConfiguration.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Branding_period_BrandingOptions.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets custom css
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Branding/Css`.
    /// - Remark: Generated from `#/paths//Branding/Css/get(getBrandingCss)`.
    internal func getBrandingCss(_ input: Operations.getBrandingCss.Input) async throws -> Operations.getBrandingCss.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getBrandingCss.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Branding/Css",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets custom css
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Branding/Css.css`.
    /// - Remark: Generated from `#/paths//Branding/Css.css/get(getBrandingCssCss)`.
    internal func getBrandingCssCss(_ input: Operations.getBrandingCssCss.Input) async throws -> Operations.getBrandingCssCss.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getBrandingCssCss.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Branding/Css.css",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Creates a Connect link for a user
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Connect/Pending`.
    /// - Remark: Generated from `#/paths//Connect/Pending/get(getConnectPending)`.
    internal func getConnectPending(_ input: Operations.getConnectPending.Input) async throws -> Operations.getConnectPending.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getConnectPending.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Connect/Pending",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets the corresponding local user from a connect user id
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Connect/Exchange`.
    /// - Remark: Generated from `#/paths//Connect/Exchange/get(getConnectExchange)`.
    internal func getConnectExchange(_ input: Operations.getConnectExchange.Input) async throws -> Operations.getConnectExchange.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getConnectExchange.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Connect/Exchange",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ConnectUserId",
                    value: input.query.ConnectUserId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getConnectExchange.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Connect_period_ConnectAuthenticationExchangeResult.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets options for a device
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Devices/Options`.
    /// - Remark: Generated from `#/paths//Devices/Options/get(getDevicesOptions)`.
    internal func getDevicesOptions(_ input: Operations.getDevicesOptions.Input) async throws -> Operations.getDevicesOptions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getDevicesOptions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Devices/Options",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Id",
                    value: input.query.Id
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getDevicesOptions.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Devices_period_DeviceOptions.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates device options
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Devices/Options`.
    /// - Remark: Generated from `#/paths//Devices/Options/post(postDevicesOptions)`.
    internal func postDevicesOptions(_ input: Operations.postDevicesOptions.Input) async throws -> Operations.postDevicesOptions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postDevicesOptions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Devices/Options",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Id",
                    value: input.query.Id
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets info for a device
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Devices/Info`.
    /// - Remark: Generated from `#/paths//Devices/Info/get(getDevicesInfo)`.
    internal func getDevicesInfo(_ input: Operations.getDevicesInfo.Input) async throws -> Operations.getDevicesInfo.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getDevicesInfo.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Devices/Info",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Id",
                    value: input.query.Id
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getDevicesInfo.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Devices_period_DeviceInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets camera upload history for a device
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Devices/CameraUploads`.
    /// - Remark: Generated from `#/paths//Devices/CameraUploads/get(getDevicesCamerauploads)`.
    internal func getDevicesCamerauploads(_ input: Operations.getDevicesCamerauploads.Input) async throws -> Operations.getDevicesCamerauploads.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getDevicesCamerauploads.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Devices/CameraUploads",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getDevicesCamerauploads.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Devices_period_ContentUploadHistory.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Uploads content
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Devices/CameraUploads`.
    /// - Remark: Generated from `#/paths//Devices/CameraUploads/post(postDevicesCamerauploads)`.
    internal func postDevicesCamerauploads(_ input: Operations.postDevicesCamerauploads.Input) async throws -> Operations.postDevicesCamerauploads.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postDevicesCamerauploads.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Devices/CameraUploads",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Album",
                    value: input.query.Album
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Name",
                    value: input.query.Name
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Id",
                    value: input.query.Id
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .binary(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/octet-stream"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deletes a device
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Devices/Delete`.
    /// - Remark: Generated from `#/paths//Devices/Delete/post(postDevicesDelete)`.
    internal func postDevicesDelete(_ input: Operations.postDevicesDelete.Input) async throws -> Operations.postDevicesDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postDevicesDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Devices/Delete",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Id",
                    value: input.query.Id
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a user's display preferences for an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /DisplayPreferences/{Id}`.
    /// - Remark: Generated from `#/paths//DisplayPreferences/{Id}/get(getDisplaypreferencesById)`.
    internal func getDisplaypreferencesById(_ input: Operations.getDisplaypreferencesById.Input) async throws -> Operations.getDisplaypreferencesById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getDisplaypreferencesById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/DisplayPreferences/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Client",
                    value: input.query.Client
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getDisplaypreferencesById.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DisplayPreferences.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates a user's display preferences for an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /DisplayPreferences/{DisplayPreferencesId}`.
    /// - Remark: Generated from `#/paths//DisplayPreferences/{DisplayPreferencesId}/post(postDisplaypreferencesByDisplaypreferencesid)`.
    internal func postDisplaypreferencesByDisplaypreferencesid(_ input: Operations.postDisplaypreferencesByDisplaypreferencesid.Input) async throws -> Operations.postDisplaypreferencesByDisplaypreferencesid.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postDisplaypreferencesByDisplaypreferencesid.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/DisplayPreferences/{}",
                    parameters: [
                        input.path.DisplayPreferencesId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a list of profiles
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Dlna/ProfileInfos`.
    /// - Remark: Generated from `#/paths//Dlna/ProfileInfos/get(getDlnaProfileinfos)`.
    internal func getDlnaProfileinfos(_ input: Operations.getDlnaProfileinfos.Input) async throws -> Operations.getDlnaProfileinfos.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getDlnaProfileinfos.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Dlna/ProfileInfos",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getDlnaProfileinfos.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Dlna_period_Profiles_period_DlnaProfile].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Creates a profile
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Dlna/Profiles`.
    /// - Remark: Generated from `#/paths//Dlna/Profiles/post(postDlnaProfiles)`.
    internal func postDlnaProfiles(_ input: Operations.postDlnaProfiles.Input) async throws -> Operations.postDlnaProfiles.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postDlnaProfiles.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Dlna/Profiles",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets available tone mapping options
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Encoding/ToneMapOptions`.
    /// - Remark: Generated from `#/paths//Encoding/ToneMapOptions/get(getEncodingTonemapoptions)`.
    internal func getEncodingTonemapoptions(_ input: Operations.getEncodingTonemapoptions.Input) async throws -> Operations.getEncodingTonemapoptions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getEncodingTonemapoptions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Encoding/ToneMapOptions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getEncodingTonemapoptions.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Configuration_period_ToneMapping_period_ToneMapOptionsVisibility.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets the tone mapping options
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Encoding/FullToneMapOptions`.
    /// - Remark: Generated from `#/paths//Encoding/FullToneMapOptions/get(getEncodingFulltonemapoptions)`.
    internal func getEncodingFulltonemapoptions(_ input: Operations.getEncodingFulltonemapoptions.Input) async throws -> Operations.getEncodingFulltonemapoptions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getEncodingFulltonemapoptions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Encoding/FullToneMapOptions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getEncodingFulltonemapoptions.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.EditObjectContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates the tone mapping options
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Encoding/FullToneMapOptions`.
    /// - Remark: Generated from `#/paths//Encoding/FullToneMapOptions/post(postEncodingFulltonemapoptions)`.
    internal func postEncodingFulltonemapoptions(_ input: Operations.postEncodingFulltonemapoptions.Input) async throws -> Operations.postEncodingFulltonemapoptions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postEncodingFulltonemapoptions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Encoding/FullToneMapOptions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .binary(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/octet-stream"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets the tone mapping options
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Encoding/PublicToneMapOptions`.
    /// - Remark: Generated from `#/paths//Encoding/PublicToneMapOptions/get(getEncodingPublictonemapoptions)`.
    internal func getEncodingPublictonemapoptions(_ input: Operations.getEncodingPublictonemapoptions.Input) async throws -> Operations.getEncodingPublictonemapoptions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getEncodingPublictonemapoptions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Encoding/PublicToneMapOptions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getEncodingPublictonemapoptions.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.EditObjectContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates the tone mapping options
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Encoding/PublicToneMapOptions`.
    /// - Remark: Generated from `#/paths//Encoding/PublicToneMapOptions/post(postEncodingPublictonemapoptions)`.
    internal func postEncodingPublictonemapoptions(_ input: Operations.postEncodingPublictonemapoptions.Input) async throws -> Operations.postEncodingPublictonemapoptions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postEncodingPublictonemapoptions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Encoding/PublicToneMapOptions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .binary(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/octet-stream"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets the subtitle options
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Encoding/SubtitleOptions`.
    /// - Remark: Generated from `#/paths//Encoding/SubtitleOptions/get(getEncodingSubtitleoptions)`.
    internal func getEncodingSubtitleoptions(_ input: Operations.getEncodingSubtitleoptions.Input) async throws -> Operations.getEncodingSubtitleoptions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getEncodingSubtitleoptions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Encoding/SubtitleOptions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getEncodingSubtitleoptions.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.EditObjectContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates the subtitle options
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Encoding/SubtitleOptions`.
    /// - Remark: Generated from `#/paths//Encoding/SubtitleOptions/post(postEncodingSubtitleoptions)`.
    internal func postEncodingSubtitleoptions(_ input: Operations.postEncodingSubtitleoptions.Input) async throws -> Operations.postEncodingSubtitleoptions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postEncodingSubtitleoptions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Encoding/SubtitleOptions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .binary(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/octet-stream"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets the ffmpeg options
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Encoding/FfmpegOptions`.
    /// - Remark: Generated from `#/paths//Encoding/FfmpegOptions/get(getEncodingFfmpegoptions)`.
    internal func getEncodingFfmpegoptions(_ input: Operations.getEncodingFfmpegoptions.Input) async throws -> Operations.getEncodingFfmpegoptions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getEncodingFfmpegoptions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Encoding/FfmpegOptions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getEncodingFfmpegoptions.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.EditObjectContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates the ffmpeg options
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Encoding/FfmpegOptions`.
    /// - Remark: Generated from `#/paths//Encoding/FfmpegOptions/post(postEncodingFfmpegoptions)`.
    internal func postEncodingFfmpegoptions(_ input: Operations.postEncodingFfmpegoptions.Input) async throws -> Operations.postEncodingFfmpegoptions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postEncodingFfmpegoptions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Encoding/FfmpegOptions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .binary(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/octet-stream"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets the parameters for a specified codec.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Encoding/CodecParameters`.
    /// - Remark: Generated from `#/paths//Encoding/CodecParameters/get(getEncodingCodecparameters)`.
    internal func getEncodingCodecparameters(_ input: Operations.getEncodingCodecparameters.Input) async throws -> Operations.getEncodingCodecparameters.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getEncodingCodecparameters.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Encoding/CodecParameters",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CodecId",
                    value: input.query.CodecId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParameterContext",
                    value: input.query.ParameterContext
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getEncodingCodecparameters.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.EditObjectContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates the parameters for a specified codec.
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Encoding/CodecParameters`.
    /// - Remark: Generated from `#/paths//Encoding/CodecParameters/post(postEncodingCodecparameters)`.
    internal func postEncodingCodecparameters(_ input: Operations.postEncodingCodecparameters.Input) async throws -> Operations.postEncodingCodecparameters.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postEncodingCodecparameters.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Encoding/CodecParameters",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CodecId",
                    value: input.query.CodecId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParameterContext",
                    value: input.query.ParameterContext
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .binary(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/octet-stream"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets the contents of a given directory in the file system
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Environment/ValidatePath`.
    /// - Remark: Generated from `#/paths//Environment/ValidatePath/post(postEnvironmentValidatepath)`.
    internal func postEnvironmentValidatepath(_ input: Operations.postEnvironmentValidatepath.Input) async throws -> Operations.postEnvironmentValidatepath.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postEnvironmentValidatepath.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Environment/ValidatePath",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Path",
                    value: input.query.Path
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets the parent path of a given path
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Environment/DefaultDirectoryBrowser`.
    /// - Remark: Generated from `#/paths//Environment/DefaultDirectoryBrowser/get(getEnvironmentDefaultdirectorybrowser)`.
    internal func getEnvironmentDefaultdirectorybrowser(_ input: Operations.getEnvironmentDefaultdirectorybrowser.Input) async throws -> Operations.getEnvironmentDefaultdirectorybrowser.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getEnvironmentDefaultdirectorybrowser.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Environment/DefaultDirectoryBrowser",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getEnvironmentDefaultdirectorybrowser.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DefaultDirectoryBrowserInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets the contents of a given directory in the file system
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Environment/DirectoryContents`.
    /// - Remark: Generated from `#/paths//Environment/DirectoryContents/get(getEnvironmentDirectorycontents)`.
    internal func getEnvironmentDirectorycontents(_ input: Operations.getEnvironmentDirectorycontents.Input) async throws -> Operations.getEnvironmentDirectorycontents.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getEnvironmentDirectorycontents.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Environment/DirectoryContents",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IncludeFiles",
                    value: input.query.IncludeFiles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IncludeDirectories",
                    value: input.query.IncludeDirectories
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getEnvironmentDirectorycontents.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.IO_period_FileSystemEntryInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets the contents of a given directory in the file system
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Environment/DirectoryContents`.
    /// - Remark: Generated from `#/paths//Environment/DirectoryContents/post(postEnvironmentDirectorycontents)`.
    internal func postEnvironmentDirectorycontents(_ input: Operations.postEnvironmentDirectorycontents.Input) async throws -> Operations.postEnvironmentDirectorycontents.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postEnvironmentDirectorycontents.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Environment/DirectoryContents",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IncludeFiles",
                    value: input.query.IncludeFiles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IncludeDirectories",
                    value: input.query.IncludeDirectories
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postEnvironmentDirectorycontents.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.IO_period_FileSystemEntryInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets shares from a network device
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Environment/NetworkShares`.
    /// - Remark: Generated from `#/paths//Environment/NetworkShares/get(getEnvironmentNetworkshares)`.
    internal func getEnvironmentNetworkshares(_ input: Operations.getEnvironmentNetworkshares.Input) async throws -> Operations.getEnvironmentNetworkshares.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getEnvironmentNetworkshares.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Environment/NetworkShares",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Path",
                    value: input.query.Path
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getEnvironmentNetworkshares.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.IO_period_FileSystemEntryInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets available drives from the server's file system
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Environment/Drives`.
    /// - Remark: Generated from `#/paths//Environment/Drives/get(getEnvironmentDrives)`.
    internal func getEnvironmentDrives(_ input: Operations.getEnvironmentDrives.Input) async throws -> Operations.getEnvironmentDrives.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getEnvironmentDrives.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Environment/Drives",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getEnvironmentDrives.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.IO_period_FileSystemEntryInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a list of devices on the network
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Environment/NetworkDevices`.
    /// - Remark: Generated from `#/paths//Environment/NetworkDevices/get(getEnvironmentNetworkdevices)`.
    internal func getEnvironmentNetworkdevices(_ input: Operations.getEnvironmentNetworkdevices.Input) async throws -> Operations.getEnvironmentNetworkdevices.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getEnvironmentNetworkdevices.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Environment/NetworkDevices",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getEnvironmentNetworkdevices.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.IO_period_FileSystemEntryInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets the parent path of a given path
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Environment/ParentPath`.
    /// - Remark: Generated from `#/paths//Environment/ParentPath/get(getEnvironmentParentpath)`.
    internal func getEnvironmentParentpath(_ input: Operations.getEnvironmentParentpath.Input) async throws -> Operations.getEnvironmentParentpath.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getEnvironmentParentpath.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Environment/ParentPath",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Path",
                    value: input.query.Path
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getEnvironmentParentpath.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Swift.String.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a Game genre, by name
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /GameGenres/{Name}`.
    /// - Remark: Generated from `#/paths//GameGenres/{Name}/get(getGamegenresByName)`.
    internal func getGamegenresByName(_ input: Operations.getGamegenresByName.Input) async throws -> Operations.getGamegenresByName.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getGamegenresByName.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/GameGenres/{}",
                    parameters: [
                        input.path.Name
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getGamegenresByName.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a genre, by name
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Genres/{Name}`.
    /// - Remark: Generated from `#/paths//Genres/{Name}/get(getGenresByName)`.
    internal func getGenresByName(_ input: Operations.getGenresByName.Input) async throws -> Operations.getGenresByName.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getGenresByName.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Genres/{}",
                    parameters: [
                        input.path.Name
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getGenresByName.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a remote image
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Images/Remote`.
    /// - Remark: Generated from `#/paths//Images/Remote/get(getImagesRemote)`.
    internal func getImagesRemote(_ input: Operations.getImagesRemote.Input) async throws -> Operations.getImagesRemote.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getImagesRemote.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Images/Remote",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageUrl",
                    value: input.query.ImageUrl
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates an item
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Items/{ItemId}`.
    /// - Remark: Generated from `#/paths//Items/{ItemId}/post(postItemsByItemid)`.
    internal func postItemsByItemid(_ input: Operations.postItemsByItemid.Input) async throws -> Operations.postItemsByItemid.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsByItemid.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}",
                    parameters: [
                        input.path.ItemId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets items based on a query.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Items/Prefixes`.
    /// - Remark: Generated from `#/paths//Items/Prefixes/get(getItemsPrefixes)`.
    internal func getItemsPrefixes(_ input: Operations.getItemsPrefixes.Input) async throws -> Operations.getItemsPrefixes.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsPrefixes.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/Prefixes",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItemsPrefixes.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.NameValuePair].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates user item access
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Items/Access`.
    /// - Remark: Generated from `#/paths//Items/Access/post(postItemsAccess)`.
    internal func postItemsAccess(_ input: Operations.postItemsAccess.Input) async throws -> Operations.postItemsAccess.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsAccess.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/Access",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Items/Counts`.
    /// - Remark: Generated from `#/paths//Items/Counts/get(getItemsCounts)`.
    internal func getItemsCounts(_ input: Operations.getItemsCounts.Input) async throws -> Operations.getItemsCounts.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsCounts.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/Counts",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItemsCounts.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ItemCounts.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets info to debug intros
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Items/Intros`.
    /// - Remark: Generated from `#/paths//Items/Intros/get(getItemsIntros)`.
    internal func getItemsIntros(_ input: Operations.getItemsIntros.Input) async throws -> Operations.getItemsIntros.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsIntros.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/Intros",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItemsIntros.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Persistence_period_IntroDebugInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deletes an item from the library and file system
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Items/Delete`.
    /// - Remark: Generated from `#/paths//Items/Delete/post(postItemsDelete)`.
    internal func postItemsDelete(_ input: Operations.postItemsDelete.Input) async throws -> Operations.postItemsDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/Delete",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Ids",
                    value: input.query.Ids
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deletes an item from the library and file system
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `DELETE /Items/{Id}`.
    /// - Remark: Generated from `#/paths//Items/{Id}/delete(deleteItemsById)`.
    internal func deleteItemsById(_ input: Operations.deleteItemsById.Input) async throws -> Operations.deleteItemsById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteItemsById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Libraries/AvailableOptions`.
    /// - Remark: Generated from `#/paths//Libraries/AvailableOptions/get(getLibrariesAvailableoptions)`.
    internal func getLibrariesAvailableoptions(_ input: Operations.getLibrariesAvailableoptions.Input) async throws -> Operations.getLibrariesAvailableoptions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLibrariesAvailableoptions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Libraries/AvailableOptions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLibrariesAvailableoptions.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Library_period_LibraryOptionsResult.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets all user media folders.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Library/SelectableMediaFolders`.
    /// - Remark: Generated from `#/paths//Library/SelectableMediaFolders/get(getLibrarySelectablemediafolders)`.
    internal func getLibrarySelectablemediafolders(_ input: Operations.getLibrarySelectablemediafolders.Input) async throws -> Operations.getLibrarySelectablemediafolders.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLibrarySelectablemediafolders.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Library/SelectableMediaFolders",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLibrarySelectablemediafolders.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Library_period_MediaFolder].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets all user media folders.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Library/MediaFolders`.
    /// - Remark: Generated from `#/paths//Library/MediaFolders/get(getLibraryMediafolders)`.
    internal func getLibraryMediafolders(_ input: Operations.getLibraryMediafolders.Input) async throws -> Operations.getLibraryMediafolders.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLibraryMediafolders.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Library/MediaFolders",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHidden",
                    value: input.query.IsHidden
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLibraryMediafolders.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a list of physical paths from virtual folders
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Library/PhysicalPaths`.
    /// - Remark: Generated from `#/paths//Library/PhysicalPaths/get(getLibraryPhysicalpaths)`.
    internal func getLibraryPhysicalpaths(_ input: Operations.getLibraryPhysicalpaths.Input) async throws -> Operations.getLibraryPhysicalpaths.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLibraryPhysicalpaths.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Library/PhysicalPaths",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLibraryPhysicalpaths.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Swift.String].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Starts a library scan
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Library/Refresh`.
    /// - Remark: Generated from `#/paths//Library/Refresh/post(postLibraryRefresh)`.
    internal func postLibraryRefresh(_ input: Operations.postLibraryRefresh.Input) async throws -> Operations.postLibraryRefresh.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLibraryRefresh.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Library/Refresh",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Library/VirtualFolders`.
    /// - Remark: Generated from `#/paths//Library/VirtualFolders/post(postLibraryVirtualfolders)`.
    internal func postLibraryVirtualfolders(_ input: Operations.postLibraryVirtualfolders.Input) async throws -> Operations.postLibraryVirtualfolders.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLibraryVirtualfolders.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Library/VirtualFolders",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `DELETE /Library/VirtualFolders`.
    /// - Remark: Generated from `#/paths//Library/VirtualFolders/delete(deleteLibraryVirtualfolders)`.
    internal func deleteLibraryVirtualfolders(_ input: Operations.deleteLibraryVirtualfolders.Input) async throws -> Operations.deleteLibraryVirtualfolders.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteLibraryVirtualfolders.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Library/VirtualFolders",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Opens a media source
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /LiveStreams/Open`.
    /// - Remark: Generated from `#/paths//LiveStreams/Open/post(postLivestreamsOpen)`.
    internal func postLivestreamsOpen(_ input: Operations.postLivestreamsOpen.Input) async throws -> Operations.postLivestreamsOpen.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLivestreamsOpen.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveStreams/Open",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postLivestreamsOpen.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LiveStreamResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Closes a media source
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /LiveStreams/Close`.
    /// - Remark: Generated from `#/paths//LiveStreams/Close/post(postLivestreamsClose)`.
    internal func postLivestreamsClose(_ input: Operations.postLivestreamsClose.Input) async throws -> Operations.postLivestreamsClose.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLivestreamsClose.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveStreams/Close",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "LiveStreamId",
                    value: input.query.LiveStreamId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Closes a media source
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /LiveStreams/MediaInfo`.
    /// - Remark: Generated from `#/paths//LiveStreams/MediaInfo/post(postLivestreamsMediainfo)`.
    internal func postLivestreamsMediainfo(_ input: Operations.postLivestreamsMediainfo.Input) async throws -> Operations.postLivestreamsMediainfo.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLivestreamsMediainfo.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveStreams/MediaInfo",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "LiveStreamId",
                    value: input.query.LiveStreamId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets live tv channel tags
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/ChannelTags`.
    /// - Remark: Generated from `#/paths//LiveTv/ChannelTags/get(getLivetvChanneltags)`.
    internal func getLivetvChanneltags(_ input: Operations.getLivetvChanneltags.Input) async throws -> Operations.getLivetvChanneltags.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvChanneltags.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/ChannelTags",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvChanneltags.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets the top level live tv folder
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/Folder`.
    /// - Remark: Generated from `#/paths//LiveTv/Folder/get(getLivetvFolder)`.
    internal func getLivetvFolder(_ input: Operations.getLivetvFolder.Input) async throws -> Operations.getLivetvFolder.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvFolder.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Folder",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvFolder.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /LiveTv/ChannelMappings`.
    /// - Remark: Generated from `#/paths//LiveTv/ChannelMappings/get(getLivetvChannelmappings)`.
    internal func getLivetvChannelmappings(_ input: Operations.getLivetvChannelmappings.Input) async throws -> Operations.getLivetvChannelmappings.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvChannelmappings.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/ChannelMappings",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProviderId",
                    value: input.query.ProviderId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /LiveTv/ChannelMappings`.
    /// - Remark: Generated from `#/paths//LiveTv/ChannelMappings/post(postLivetvChannelmappings)`.
    internal func postLivetvChannelmappings(_ input: Operations.postLivetvChannelmappings.Input) async throws -> Operations.postLivetvChannelmappings.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLivetvChannelmappings.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/ChannelMappings",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProviderId",
                    value: input.query.ProviderId
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `PUT /LiveTv/ChannelMappings`.
    /// - Remark: Generated from `#/paths//LiveTv/ChannelMappings/put(putLivetvChannelmappings)`.
    internal func putLivetvChannelmappings(_ input: Operations.putLivetvChannelmappings.Input) async throws -> Operations.putLivetvChannelmappings.Output {
        try await client.send(
            input: input,
            forOperation: Operations.putLivetvChannelmappings.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/ChannelMappings",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProviderId",
                    value: input.query.ProviderId
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `DELETE /LiveTv/ChannelMappings`.
    /// - Remark: Generated from `#/paths//LiveTv/ChannelMappings/delete(deleteLivetvChannelmappings)`.
    internal func deleteLivetvChannelmappings(_ input: Operations.deleteLivetvChannelmappings.Input) async throws -> Operations.deleteLivetvChannelmappings.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteLivetvChannelmappings.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/ChannelMappings",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProviderId",
                    value: input.query.ProviderId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `HEAD /LiveTv/ChannelMappings`.
    /// - Remark: Generated from `#/paths//LiveTv/ChannelMappings/head(headLivetvChannelmappings)`.
    internal func headLivetvChannelmappings(_ input: Operations.headLivetvChannelmappings.Input) async throws -> Operations.headLivetvChannelmappings.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headLivetvChannelmappings.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/ChannelMappings",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProviderId",
                    value: input.query.ProviderId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /LiveTv/ChannelMappingOptions`.
    /// - Remark: Generated from `#/paths//LiveTv/ChannelMappingOptions/get(getLivetvChannelmappingoptions)`.
    internal func getLivetvChannelmappingoptions(_ input: Operations.getLivetvChannelmappingoptions.Input) async throws -> Operations.getLivetvChannelmappingoptions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvChannelmappingoptions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/ChannelMappingOptions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProviderId",
                    value: input.query.ProviderId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /LiveTv/ChannelMappingOptions`.
    /// - Remark: Generated from `#/paths//LiveTv/ChannelMappingOptions/post(postLivetvChannelmappingoptions)`.
    internal func postLivetvChannelmappingoptions(_ input: Operations.postLivetvChannelmappingoptions.Input) async throws -> Operations.postLivetvChannelmappingoptions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLivetvChannelmappingoptions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/ChannelMappingOptions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProviderId",
                    value: input.query.ProviderId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `PUT /LiveTv/ChannelMappingOptions`.
    /// - Remark: Generated from `#/paths//LiveTv/ChannelMappingOptions/put(putLivetvChannelmappingoptions)`.
    internal func putLivetvChannelmappingoptions(_ input: Operations.putLivetvChannelmappingoptions.Input) async throws -> Operations.putLivetvChannelmappingoptions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.putLivetvChannelmappingoptions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/ChannelMappingOptions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProviderId",
                    value: input.query.ProviderId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `DELETE /LiveTv/ChannelMappingOptions`.
    /// - Remark: Generated from `#/paths//LiveTv/ChannelMappingOptions/delete(deleteLivetvChannelmappingoptions)`.
    internal func deleteLivetvChannelmappingoptions(_ input: Operations.deleteLivetvChannelmappingoptions.Input) async throws -> Operations.deleteLivetvChannelmappingoptions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteLivetvChannelmappingoptions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/ChannelMappingOptions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProviderId",
                    value: input.query.ProviderId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `HEAD /LiveTv/ChannelMappingOptions`.
    /// - Remark: Generated from `#/paths//LiveTv/ChannelMappingOptions/head(headLivetvChannelmappingoptions)`.
    internal func headLivetvChannelmappingoptions(_ input: Operations.headLivetvChannelmappingoptions.Input) async throws -> Operations.headLivetvChannelmappingoptions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headLivetvChannelmappingoptions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/ChannelMappingOptions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProviderId",
                    value: input.query.ProviderId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets current listing providers
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /LiveTv/ListingProviders`.
    /// - Remark: Generated from `#/paths//LiveTv/ListingProviders/get(getLivetvListingproviders)`.
    internal func getLivetvListingproviders(_ input: Operations.getLivetvListingproviders.Input) async throws -> Operations.getLivetvListingproviders.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvListingproviders.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/ListingProviders",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ChannelId",
                    value: input.query.ChannelId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvListingproviders.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.LiveTv_period_ListingsProviderInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Adds a listing provider
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /LiveTv/ListingProviders`.
    /// - Remark: Generated from `#/paths//LiveTv/ListingProviders/post(postLivetvListingproviders)`.
    internal func postLivetvListingproviders(_ input: Operations.postLivetvListingproviders.Input) async throws -> Operations.postLivetvListingproviders.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLivetvListingproviders.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/ListingProviders",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postLivetvListingproviders.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LiveTv_period_ListingsProviderInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deletes a listing provider
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `DELETE /LiveTv/ListingProviders`.
    /// - Remark: Generated from `#/paths//LiveTv/ListingProviders/delete(deleteLivetvListingproviders)`.
    internal func deleteLivetvListingproviders(_ input: Operations.deleteLivetvListingproviders.Input) async throws -> Operations.deleteLivetvListingproviders.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteLivetvListingproviders.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/ListingProviders",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Id",
                    value: input.query.Id
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets tuner hosts
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /LiveTv/TunerHosts`.
    /// - Remark: Generated from `#/paths//LiveTv/TunerHosts/get(getLivetvTunerhosts)`.
    internal func getLivetvTunerhosts(_ input: Operations.getLivetvTunerhosts.Input) async throws -> Operations.getLivetvTunerhosts.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvTunerhosts.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/TunerHosts",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvTunerhosts.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.LiveTv_period_TunerHostInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Adds a tuner host
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /LiveTv/TunerHosts`.
    /// - Remark: Generated from `#/paths//LiveTv/TunerHosts/post(postLivetvTunerhosts)`.
    internal func postLivetvTunerhosts(_ input: Operations.postLivetvTunerhosts.Input) async throws -> Operations.postLivetvTunerhosts.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLivetvTunerhosts.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/TunerHosts",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postLivetvTunerhosts.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LiveTv_period_TunerHostInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deletes a tuner host
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `DELETE /LiveTv/TunerHosts`.
    /// - Remark: Generated from `#/paths//LiveTv/TunerHosts/delete(deleteLivetvTunerhosts)`.
    internal func deleteLivetvTunerhosts(_ input: Operations.deleteLivetvTunerhosts.Input) async throws -> Operations.deleteLivetvTunerhosts.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteLivetvTunerhosts.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/TunerHosts",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Id",
                    value: input.query.Id
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets available live tv services.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/Info`.
    /// - Remark: Generated from `#/paths//LiveTv/Info/get(getLivetvInfo)`.
    internal func getLivetvInfo(_ input: Operations.getLivetvInfo.Input) async throws -> Operations.getLivetvInfo.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvInfo.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Info",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvInfo.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LiveTv_period_LiveTvInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets the epg.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/EPG`.
    /// - Remark: Generated from `#/paths//LiveTv/EPG/get(getLivetvEPG)`.
    internal func getLivetvEPG(_ input: Operations.getLivetvEPG.Input) async throws -> Operations.getLivetvEPG.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvEPG.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/EPG",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Type",
                    value: input.query._Type
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLiked",
                    value: input.query.IsLiked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsDisliked",
                    value: input.query.IsDisliked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableFavoriteSorting",
                    value: input.query.EnableFavoriteSorting
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AddCurrentProgram",
                    value: input.query.AddCurrentProgram
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ChannelIds",
                    value: input.query.ChannelIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvEPG.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_Api_period_EpgRow.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets available live tv channels.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/Channels`.
    /// - Remark: Generated from `#/paths//LiveTv/Channels/get(getLivetvChannels)`.
    internal func getLivetvChannels(_ input: Operations.getLivetvChannels.Input) async throws -> Operations.getLivetvChannels.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvChannels.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Channels",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Type",
                    value: input.query._Type
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLiked",
                    value: input.query.IsLiked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsDisliked",
                    value: input.query.IsDisliked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableFavoriteSorting",
                    value: input.query.EnableFavoriteSorting
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AddCurrentProgram",
                    value: input.query.AddCurrentProgram
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvChannels.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets available live tv epgs..
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/Programs`.
    /// - Remark: Generated from `#/paths//LiveTv/Programs/get(getLivetvPrograms)`.
    internal func getLivetvPrograms(_ input: Operations.getLivetvPrograms.Input) async throws -> Operations.getLivetvPrograms.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvPrograms.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Programs",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ChannelIds",
                    value: input.query.ChannelIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets available live tv epgs..
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /LiveTv/Programs`.
    /// - Remark: Generated from `#/paths//LiveTv/Programs/post(postLivetvPrograms)`.
    internal func postLivetvPrograms(_ input: Operations.postLivetvPrograms.Input) async throws -> Operations.postLivetvPrograms.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLivetvPrograms.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Programs",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ChannelIds",
                    value: input.query.ChannelIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets live tv recordings
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/Recordings`.
    /// - Remark: Generated from `#/paths//LiveTv/Recordings/get(getLivetvRecordings)`.
    internal func getLivetvRecordings(_ input: Operations.getLivetvRecordings.Input) async throws -> Operations.getLivetvRecordings.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvRecordings.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Recordings",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ChannelId",
                    value: input.query.ChannelId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Status",
                    value: input.query.Status
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsInProgress",
                    value: input.query.IsInProgress
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SeriesTimerId",
                    value: input.query.SeriesTimerId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets live tv timers
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/Timers`.
    /// - Remark: Generated from `#/paths//LiveTv/Timers/get(getLivetvTimers)`.
    internal func getLivetvTimers(_ input: Operations.getLivetvTimers.Input) async throws -> Operations.getLivetvTimers.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvTimers.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Timers",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ChannelId",
                    value: input.query.ChannelId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SeriesTimerId",
                    value: input.query.SeriesTimerId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvTimers.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_LiveTv_period_TimerInfoDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Creates a live tv timer
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /LiveTv/Timers`.
    /// - Remark: Generated from `#/paths//LiveTv/Timers/post(postLivetvTimers)`.
    internal func postLivetvTimers(_ input: Operations.postLivetvTimers.Input) async throws -> Operations.postLivetvTimers.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLivetvTimers.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Timers",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets live tv series timers
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/SeriesTimers`.
    /// - Remark: Generated from `#/paths//LiveTv/SeriesTimers/get(getLivetvSeriestimers)`.
    internal func getLivetvSeriestimers(_ input: Operations.getLivetvSeriestimers.Input) async throws -> Operations.getLivetvSeriestimers.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvSeriestimers.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/SeriesTimers",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvSeriestimers.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_LiveTv_period_SeriesTimerInfoDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Creates a live tv series timer
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /LiveTv/SeriesTimers`.
    /// - Remark: Generated from `#/paths//LiveTv/SeriesTimers/post(postLivetvSeriestimers)`.
    internal func postLivetvSeriestimers(_ input: Operations.postLivetvSeriestimers.Input) async throws -> Operations.postLivetvSeriestimers.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLivetvSeriestimers.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/SeriesTimers",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets guide info
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/GuideInfo`.
    /// - Remark: Generated from `#/paths//LiveTv/GuideInfo/get(getLivetvGuideinfo)`.
    internal func getLivetvGuideinfo(_ input: Operations.getLivetvGuideinfo.Input) async throws -> Operations.getLivetvGuideinfo.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvGuideinfo.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/GuideInfo",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvGuideinfo.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LiveTv_period_GuideInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets available recording options
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/AvailableRecordingOptions`.
    /// - Remark: Generated from `#/paths//LiveTv/AvailableRecordingOptions/get(getLivetvAvailablerecordingoptions)`.
    internal func getLivetvAvailablerecordingoptions(_ input: Operations.getLivetvAvailablerecordingoptions.Input) async throws -> Operations.getLivetvAvailablerecordingoptions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvAvailablerecordingoptions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/AvailableRecordingOptions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvAvailablerecordingoptions.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Api_period_AvailableRecordingOptions.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets known parental ratings
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Localization/ParentalRatings`.
    /// - Remark: Generated from `#/paths//Localization/ParentalRatings/get(getLocalizationParentalratings)`.
    internal func getLocalizationParentalratings(_ input: Operations.getLocalizationParentalratings.Input) async throws -> Operations.getLocalizationParentalratings.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLocalizationParentalratings.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Localization/ParentalRatings",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLocalizationParentalratings.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.ParentalRating].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets localization options
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Localization/Options`.
    /// - Remark: Generated from `#/paths//Localization/Options/get(getLocalizationOptions)`.
    internal func getLocalizationOptions(_ input: Operations.getLocalizationOptions.Input) async throws -> Operations.getLocalizationOptions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLocalizationOptions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Localization/Options",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLocalizationOptions.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Globalization_period_LocalizatonOption].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets known countries
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Localization/Countries`.
    /// - Remark: Generated from `#/paths//Localization/Countries/get(getLocalizationCountries)`.
    internal func getLocalizationCountries(_ input: Operations.getLocalizationCountries.Input) async throws -> Operations.getLocalizationCountries.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLocalizationCountries.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Localization/Countries",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLocalizationCountries.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Globalization_period_CountryInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets known cultures
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Localization/Cultures`.
    /// - Remark: Generated from `#/paths//Localization/Cultures/get(getLocalizationCultures)`.
    internal func getLocalizationCultures(_ input: Operations.getLocalizationCultures.Input) async throws -> Operations.getLocalizationCultures.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLocalizationCultures.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Localization/Cultures",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLocalizationCultures.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Globalization_period_CultureDto].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets movie recommendations
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Movies/Recommendations`.
    /// - Remark: Generated from `#/paths//Movies/Recommendations/get(getMoviesRecommendations)`.
    internal func getMoviesRecommendations(_ input: Operations.getMoviesRecommendations.Input) async throws -> Operations.getMoviesRecommendations.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getMoviesRecommendations.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Movies/Recommendations",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CategoryLimit",
                    value: input.query.CategoryLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ItemLimit",
                    value: input.query.ItemLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getMoviesRecommendations.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.RecommendationDto].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a music genre, by name
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /MusicGenres/{Name}`.
    /// - Remark: Generated from `#/paths//MusicGenres/{Name}/get(getMusicgenresByName)`.
    internal func getMusicgenresByName(_ input: Operations.getMusicgenresByName.Input) async throws -> Operations.getMusicgenresByName.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getMusicgenresByName.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/MusicGenres/{}",
                    parameters: [
                        input.path.Name
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getMusicgenresByName.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Creates an instant playlist based on a music genre
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /MusicGenres/InstantMix`.
    /// - Remark: Generated from `#/paths//MusicGenres/InstantMix/get(getMusicgenresInstantmix)`.
    internal func getMusicgenresInstantmix(_ input: Operations.getMusicgenresInstantmix.Input) async throws -> Operations.getMusicgenresInstantmix.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getMusicgenresInstantmix.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/MusicGenres/InstantMix",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getMusicgenresInstantmix.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets notification types
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Notifications/Types`.
    /// - Remark: Generated from `#/paths//Notifications/Types/get(getNotificationsTypes)`.
    internal func getNotificationsTypes(_ input: Operations.getNotificationsTypes.Input) async throws -> Operations.getNotificationsTypes.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getNotificationsTypes.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Notifications/Types",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getNotificationsTypes.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.NotificationCategoryInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Sends a notification to all admin users
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Notifications/Admin`.
    /// - Remark: Generated from `#/paths//Notifications/Admin/post(postNotificationsAdmin)`.
    internal func postNotificationsAdmin(_ input: Operations.postNotificationsAdmin.Input) async throws -> Operations.postNotificationsAdmin.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postNotificationsAdmin.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Notifications/Admin",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Name",
                    value: input.query.Name
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Description",
                    value: input.query.Description
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageUrl",
                    value: input.query.ImageUrl
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Url",
                    value: input.query.Url
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Level",
                    value: input.query.Level
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets available package updates for currently installed packages
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Packages/Updates`.
    /// - Remark: Generated from `#/paths//Packages/Updates/get(getPackagesUpdates)`.
    internal func getPackagesUpdates(_ input: Operations.getPackagesUpdates.Input) async throws -> Operations.getPackagesUpdates.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getPackagesUpdates.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Packages/Updates",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PackageType",
                    value: input.query.PackageType
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getPackagesUpdates.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.PackageVersionInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a package, by name or assembly guid
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Packages/{Name}`.
    /// - Remark: Generated from `#/paths//Packages/{Name}/get(getPackagesByName)`.
    internal func getPackagesByName(_ input: Operations.getPackagesByName.Input) async throws -> Operations.getPackagesByName.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getPackagesByName.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Packages/{}",
                    parameters: [
                        input.path.Name
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AssemblyGuid",
                    value: input.query.AssemblyGuid
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getPackagesByName.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PackageInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a person, by name
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Persons/{Name}`.
    /// - Remark: Generated from `#/paths//Persons/{Name}/get(getPersonsByName)`.
    internal func getPersonsByName(_ input: Operations.getPersonsByName.Input) async throws -> Operations.getPersonsByName.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getPersonsByName.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Persons/{}",
                    parameters: [
                        input.path.Name
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getPersonsByName.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Playback/BitrateTest`.
    /// - Remark: Generated from `#/paths//Playback/BitrateTest/get(getPlaybackBitratetest)`.
    internal func getPlaybackBitratetest(_ input: Operations.getPlaybackBitratetest.Input) async throws -> Operations.getPlaybackBitratetest.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getPlaybackBitratetest.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Playback/BitrateTest",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Size",
                    value: input.query.Size
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Uninstalls a plugin
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `DELETE /Plugins/{Id}`.
    /// - Remark: Generated from `#/paths//Plugins/{Id}/delete(deletePluginsById)`.
    internal func deletePluginsById(_ input: Operations.deletePluginsById.Input) async throws -> Operations.deletePluginsById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deletePluginsById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Plugins/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a scheduled task, by Id
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /ScheduledTasks/{Id}`.
    /// - Remark: Generated from `#/paths//ScheduledTasks/{Id}/get(getScheduledtasksById)`.
    internal func getScheduledtasksById(_ input: Operations.getScheduledtasksById.Input) async throws -> Operations.getScheduledtasksById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getScheduledtasksById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/ScheduledTasks/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getScheduledtasksById.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.TaskInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a the current play queue from a session
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Sessions/PlayQueue`.
    /// - Remark: Generated from `#/paths//Sessions/PlayQueue/get(getSessionsPlayqueue)`.
    internal func getSessionsPlayqueue(_ input: Operations.getSessionsPlayqueue.Input) async throws -> Operations.getSessionsPlayqueue.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSessionsPlayqueue.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sessions/PlayQueue",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Id",
                    value: input.query.Id
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSessionsPlayqueue.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Reports that a session has ended
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sessions/Logout`.
    /// - Remark: Generated from `#/paths//Sessions/Logout/post(postSessionsLogout)`.
    internal func postSessionsLogout(_ input: Operations.postSessionsLogout.Input) async throws -> Operations.postSessionsLogout.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSessionsLogout.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sessions/Logout",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates capabilities for a device
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sessions/Capabilities`.
    /// - Remark: Generated from `#/paths//Sessions/Capabilities/post(postSessionsCapabilities)`.
    internal func postSessionsCapabilities(_ input: Operations.postSessionsCapabilities.Input) async throws -> Operations.postSessionsCapabilities.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSessionsCapabilities.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sessions/Capabilities",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Id",
                    value: input.query.Id
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PlayableMediaTypes",
                    value: input.query.PlayableMediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SupportedCommands",
                    value: input.query.SupportedCommands
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SupportsMediaControl",
                    value: input.query.SupportsMediaControl
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SupportsSync",
                    value: input.query.SupportsSync
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Reports playback has started within a session
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sessions/Playing`.
    /// - Remark: Generated from `#/paths//Sessions/Playing/post(postSessionsPlaying)`.
    internal func postSessionsPlaying(_ input: Operations.postSessionsPlaying.Input) async throws -> Operations.postSessionsPlaying.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSessionsPlaying.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sessions/Playing",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a list of missing episodes
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Shows/Missing`.
    /// - Remark: Generated from `#/paths//Shows/Missing/get(getShowsMissing)`.
    internal func getShowsMissing(_ input: Operations.getShowsMissing.Input) async throws -> Operations.getShowsMissing.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getShowsMissing.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Shows/Missing",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a list of upcoming episodes
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Shows/Upcoming`.
    /// - Remark: Generated from `#/paths//Shows/Upcoming/get(getShowsUpcoming)`.
    internal func getShowsUpcoming(_ input: Operations.getShowsUpcoming.Input) async throws -> Operations.getShowsUpcoming.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getShowsUpcoming.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Shows/Upcoming",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a list of next up episodes
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Shows/NextUp`.
    /// - Remark: Generated from `#/paths//Shows/NextUp/get(getShowsNextup)`.
    internal func getShowsNextup(_ input: Operations.getShowsNextup.Input) async throws -> Operations.getShowsNextup.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getShowsNextup.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Shows/NextUp",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SeriesId",
                    value: input.query.SeriesId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getShowsNextup.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a studio, by name
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Studios/{Name}`.
    /// - Remark: Generated from `#/paths//Studios/{Name}/get(getStudiosByName)`.
    internal func getStudiosByName(_ input: Operations.getStudiosByName.Input) async throws -> Operations.getStudiosByName.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getStudiosByName.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Studios/{}",
                    parameters: [
                        input.path.Name
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getStudiosByName.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a list of available sync targets.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Sync/Targets`.
    /// - Remark: Generated from `#/paths//Sync/Targets/get(getSyncTargets)`.
    internal func getSyncTargets(_ input: Operations.getSyncTargets.Input) async throws -> Operations.getSyncTargets.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSyncTargets.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sync/Targets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSyncTargets.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.SyncTarget].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets sync jobs.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Sync/Jobs`.
    /// - Remark: Generated from `#/paths//Sync/Jobs/get(getSyncJobs)`.
    internal func getSyncJobs(_ input: Operations.getSyncJobs.Input) async throws -> Operations.getSyncJobs.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSyncJobs.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sync/Jobs",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSyncJobs.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_SyncJob.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets sync jobs.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sync/Jobs`.
    /// - Remark: Generated from `#/paths//Sync/Jobs/post(postSyncJobs)`.
    internal func postSyncJobs(_ input: Operations.postSyncJobs.Input) async throws -> Operations.postSyncJobs.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSyncJobs.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sync/Jobs",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postSyncJobs.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SyncJobCreationResult.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets sync job items.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Sync/JobItems`.
    /// - Remark: Generated from `#/paths//Sync/JobItems/get(getSyncJobitems)`.
    internal func getSyncJobitems(_ input: Operations.getSyncJobitems.Input) async throws -> Operations.getSyncJobitems.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSyncJobitems.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sync/JobItems",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "TargetId",
                    value: input.query.TargetId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSyncJobitems.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_SyncJobItem.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a list of available sync targets.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Sync/Options`.
    /// - Remark: Generated from `#/paths//Sync/Options/get(getSyncOptions)`.
    internal func getSyncOptions(_ input: Operations.getSyncOptions.Input) async throws -> Operations.getSyncOptions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSyncOptions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sync/Options",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ItemIds",
                    value: input.query.ItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "TargetId",
                    value: input.query.TargetId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Category",
                    value: input.query.Category
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSyncOptions.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SyncDialogOptions.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Reports an action that occurred while offline.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sync/OfflineActions`.
    /// - Remark: Generated from `#/paths//Sync/OfflineActions/post(postSyncOfflineactions)`.
    internal func postSyncOfflineactions(_ input: Operations.postSyncOfflineactions.Input) async throws -> Operations.postSyncOfflineactions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSyncOfflineactions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sync/OfflineActions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Syncs data between device and server
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sync/Data`.
    /// - Remark: Generated from `#/paths//Sync/Data/post(postSyncData)`.
    internal func postSyncData(_ input: Operations.postSyncData.Input) async throws -> Operations.postSyncData.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSyncData.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sync/Data",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "TargetId",
                    value: input.query.TargetId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postSyncData.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SyncDataResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets application configuration
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /System/Configuration`.
    /// - Remark: Generated from `#/paths//System/Configuration/get(getSystemConfiguration)`.
    internal func getSystemConfiguration(_ input: Operations.getSystemConfiguration.Input) async throws -> Operations.getSystemConfiguration.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSystemConfiguration.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/Configuration",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSystemConfiguration.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ServerConfiguration.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates application configuration
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /System/Configuration`.
    /// - Remark: Generated from `#/paths//System/Configuration/post(postSystemConfiguration)`.
    internal func postSystemConfiguration(_ input: Operations.postSystemConfiguration.Input) async throws -> Operations.postSystemConfiguration.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSystemConfiguration.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/Configuration",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets release notes
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /System/ReleaseNotes`.
    /// - Remark: Generated from `#/paths//System/ReleaseNotes/get(getSystemReleasenotes)`.
    internal func getSystemReleasenotes(_ input: Operations.getSystemReleasenotes.Input) async throws -> Operations.getSystemReleasenotes.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSystemReleasenotes.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/ReleaseNotes",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSystemReleasenotes.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PackageVersionInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /System/Ping`.
    /// - Remark: Generated from `#/paths//System/Ping/get(getSystemPing)`.
    internal func getSystemPing(_ input: Operations.getSystemPing.Input) async throws -> Operations.getSystemPing.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSystemPing.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/Ping",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /System/Ping`.
    /// - Remark: Generated from `#/paths//System/Ping/post(postSystemPing)`.
    internal func postSystemPing(_ input: Operations.postSystemPing.Input) async throws -> Operations.postSystemPing.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSystemPing.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/Ping",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets wake on lan information
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /System/WakeOnLanInfo`.
    /// - Remark: Generated from `#/paths//System/WakeOnLanInfo/get(getSystemWakeonlaninfo)`.
    internal func getSystemWakeonlaninfo(_ input: Operations.getSystemWakeonlaninfo.Input) async throws -> Operations.getSystemWakeonlaninfo.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSystemWakeonlaninfo.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/WakeOnLanInfo",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSystemWakeonlaninfo.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.WakeOnLanInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets information about the server
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /System/Info`.
    /// - Remark: Generated from `#/paths//System/Info/get(getSystemInfo)`.
    internal func getSystemInfo(_ input: Operations.getSystemInfo.Input) async throws -> Operations.getSystemInfo.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSystemInfo.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/Info",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSystemInfo.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SystemInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Restarts the application, if needed
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /System/Restart`.
    /// - Remark: Generated from `#/paths//System/Restart/post(postSystemRestart)`.
    internal func postSystemRestart(_ input: Operations.postSystemRestart.Input) async throws -> Operations.postSystemRestart.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSystemRestart.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/Restart",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Shuts down the application
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /System/Shutdown`.
    /// - Remark: Generated from `#/paths//System/Shutdown/post(postSystemShutdown)`.
    internal func postSystemShutdown(_ input: Operations.postSystemShutdown.Input) async throws -> Operations.postSystemShutdown.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSystemShutdown.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/Shutdown",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets information about the request endpoint
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /System/Endpoint`.
    /// - Remark: Generated from `#/paths//System/Endpoint/get(getSystemEndpoint)`.
    internal func getSystemEndpoint(_ input: Operations.getSystemEndpoint.Input) async throws -> Operations.getSystemEndpoint.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSystemEndpoint.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/Endpoint",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSystemEndpoint.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Net_period_EndPointInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets UI view data
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /UI/View`.
    /// - Remark: Generated from `#/paths//UI/View/get(getUIView)`.
    internal func getUIView(_ input: Operations.getUIView.Input) async throws -> Operations.getUIView.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUIView.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/UI/View",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PageId",
                    value: input.query.PageId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ClientLocale",
                    value: input.query.ClientLocale
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getUIView.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UIViewInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Execute a command in the context of tv setup
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /UI/Command`.
    /// - Remark: Generated from `#/paths//UI/Command/post(postUICommand)`.
    internal func postUICommand(_ input: Operations.postUICommand.Input) async throws -> Operations.postUICommand.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUICommand.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/UI/Command",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postUICommand.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UIViewInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a list of publicly visible users for display on a login screen.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Users/Public`.
    /// - Remark: Generated from `#/paths//Users/Public/get(getUsersPublic)`.
    internal func getUsersPublic(_ input: Operations.getUsersPublic.Input) async throws -> Operations.getUsersPublic.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUsersPublic.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/Public",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getUsersPublic.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.UserDto].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a list of users
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Users/Query`.
    /// - Remark: Generated from `#/paths//Users/Query/get(getUsersQuery)`.
    internal func getUsersQuery(_ input: Operations.getUsersQuery.Input) async throws -> Operations.getUsersQuery.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUsersQuery.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/Query",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHidden",
                    value: input.query.IsHidden
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsDisabled",
                    value: input.query.IsDisabled
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getUsersQuery.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_UserDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a list of users
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Users/Prefixes`.
    /// - Remark: Generated from `#/paths//Users/Prefixes/get(getUsersPrefixes)`.
    internal func getUsersPrefixes(_ input: Operations.getUsersPrefixes.Input) async throws -> Operations.getUsersPrefixes.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUsersPrefixes.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/Prefixes",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHidden",
                    value: input.query.IsHidden
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsDisabled",
                    value: input.query.IsDisabled
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getUsersPrefixes.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.NameIdPair].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a list of users
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Users/ItemAccess`.
    /// - Remark: Generated from `#/paths//Users/ItemAccess/get(getUsersItemaccess)`.
    internal func getUsersItemaccess(_ input: Operations.getUsersItemaccess.Input) async throws -> Operations.getUsersItemaccess.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUsersItemaccess.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/ItemAccess",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHidden",
                    value: input.query.IsHidden
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsDisabled",
                    value: input.query.IsDisabled
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getUsersItemaccess.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_UserDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a user by Id
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Users/{Id}`.
    /// - Remark: Generated from `#/paths//Users/{Id}/get(getUsersById)`.
    internal func getUsersById(_ input: Operations.getUsersById.Input) async throws -> Operations.getUsersById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUsersById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getUsersById.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates a user
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{Id}`.
    /// - Remark: Generated from `#/paths//Users/{Id}/post(postUsersById)`.
    internal func postUsersById(_ input: Operations.postUsersById.Input) async throws -> Operations.postUsersById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deletes a user
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `DELETE /Users/{Id}`.
    /// - Remark: Generated from `#/paths//Users/{Id}/delete(deleteUsersById)`.
    internal func deleteUsersById(_ input: Operations.deleteUsersById.Input) async throws -> Operations.deleteUsersById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteUsersById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Authenticates a user
    ///
    /// Authenticate a user by nane and password. A 200 status code indicates success, while anything in the 400 or 500 range indicates failure
    /// ---
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/AuthenticateByName`.
    /// - Remark: Generated from `#/paths//Users/AuthenticateByName/post(postUsersAuthenticatebyname)`.
    internal func postUsersAuthenticatebyname(_ input: Operations.postUsersAuthenticatebyname.Input) async throws -> Operations.postUsersAuthenticatebyname.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersAuthenticatebyname.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/AuthenticateByName",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-Emby-Authorization",
                    value: input.headers.X_hyphen_Emby_hyphen_Authorization
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postUsersAuthenticatebyname.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Authentication_period_AuthenticationResult.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Creates a user
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Users/New`.
    /// - Remark: Generated from `#/paths//Users/New/post(postUsersNew)`.
    internal func postUsersNew(_ input: Operations.postUsersNew.Input) async throws -> Operations.postUsersNew.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersNew.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/New",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postUsersNew.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Initiates the forgot password process for a local user
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/ForgotPassword`.
    /// - Remark: Generated from `#/paths//Users/ForgotPassword/post(postUsersForgotpassword)`.
    internal func postUsersForgotpassword(_ input: Operations.postUsersForgotpassword.Input) async throws -> Operations.postUsersForgotpassword.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersForgotpassword.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/ForgotPassword",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postUsersForgotpassword.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ForgotPasswordResult.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Merges videos into a single record
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Videos/MergeVersions`.
    /// - Remark: Generated from `#/paths//Videos/MergeVersions/post(postVideosMergeversions)`.
    internal func postVideosMergeversions(_ input: Operations.postVideosMergeversions.Input) async throws -> Operations.postVideosMergeversions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postVideosMergeversions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/MergeVersions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `DELETE /Videos/ActiveEncodings`.
    /// - Remark: Generated from `#/paths//Videos/ActiveEncodings/delete(deleteVideosActiveencodings)`.
    internal func deleteVideosActiveencodings(_ input: Operations.deleteVideosActiveencodings.Input) async throws -> Operations.deleteVideosActiveencodings.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteVideosActiveencodings.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/ActiveEncodings",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PlaySessionId",
                    value: input.query.PlaySessionId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /web/ConfigurationPage`.
    /// - Remark: Generated from `#/paths//web/ConfigurationPage/get(getWebConfigurationpage)`.
    internal func getWebConfigurationpage(_ input: Operations.getWebConfigurationpage.Input) async throws -> Operations.getWebConfigurationpage.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getWebConfigurationpage.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/web/ConfigurationPage",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /web/ConfigurationPages`.
    /// - Remark: Generated from `#/paths//web/ConfigurationPages/get(getWebConfigurationpages)`.
    internal func getWebConfigurationpages(_ input: Operations.getWebConfigurationpages.Input) async throws -> Operations.getWebConfigurationpages.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getWebConfigurationpages.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/web/ConfigurationPages",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getWebConfigurationpages.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Api_period_ConfigurationPageInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /web/strings`.
    /// - Remark: Generated from `#/paths//web/strings/get(getWebStrings)`.
    internal func getWebStrings(_ input: Operations.getWebStrings.Input) async throws -> Operations.getWebStrings.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getWebStrings.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/web/strings",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /web/stringset`.
    /// - Remark: Generated from `#/paths//web/stringset/get(getWebStringset)`.
    internal func getWebStringset(_ input: Operations.getWebStringset.Input) async throws -> Operations.getWebStringset.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getWebStringset.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/web/stringset",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getWebStringset.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Swift.String].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Creates an instant playlist based on a given album
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Albums/{Id}/InstantMix`.
    /// - Remark: Generated from `#/paths//Albums/{Id}/InstantMix/get(getAlbumsByIdInstantmix)`.
    internal func getAlbumsByIdInstantmix(_ input: Operations.getAlbumsByIdInstantmix.Input) async throws -> Operations.getAlbumsByIdInstantmix.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAlbumsByIdInstantmix.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Albums/{}/InstantMix",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAlbumsByIdInstantmix.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Finds albums similar to a given album.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Albums/{Id}/Similar`.
    /// - Remark: Generated from `#/paths//Albums/{Id}/Similar/get(getAlbumsByIdSimilar)`.
    internal func getAlbumsByIdSimilar(_ input: Operations.getAlbumsByIdSimilar.Input) async throws -> Operations.getAlbumsByIdSimilar.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAlbumsByIdSimilar.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Albums/{}/Similar",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAlbumsByIdSimilar.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Finds albums similar to a given album.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Artists/{Id}/Similar`.
    /// - Remark: Generated from `#/paths//Artists/{Id}/Similar/get(getArtistsByIdSimilar)`.
    internal func getArtistsByIdSimilar(_ input: Operations.getArtistsByIdSimilar.Input) async throws -> Operations.getArtistsByIdSimilar.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getArtistsByIdSimilar.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Artists/{}/Similar",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getArtistsByIdSimilar.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets an audio stream
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Audio/{Id}/universal.{Container}`.
    /// - Remark: Generated from `#/paths//Audio/{Id}/universal.{Container}/get(getAudioByIdUniversalByContainer)`.
    internal func getAudioByIdUniversalByContainer(_ input: Operations.getAudioByIdUniversalByContainer.Input) async throws -> Operations.getAudioByIdUniversalByContainer.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAudioByIdUniversalByContainer.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Audio/{}/universal.{}",
                    parameters: [
                        input.path.Id,
                        input.path.Container
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartTimeTicks",
                    value: input.query.StartTimeTicks
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets an audio stream
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Audio/{Id}/universal.{Container}`.
    /// - Remark: Generated from `#/paths//Audio/{Id}/universal.{Container}/head(headAudioByIdUniversalByContainer)`.
    internal func headAudioByIdUniversalByContainer(_ input: Operations.headAudioByIdUniversalByContainer.Input) async throws -> Operations.headAudioByIdUniversalByContainer.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headAudioByIdUniversalByContainer.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Audio/{}/universal.{}",
                    parameters: [
                        input.path.Id,
                        input.path.Container
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartTimeTicks",
                    value: input.query.StartTimeTicks
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets an audio stream
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Audio/{Id}/universal`.
    /// - Remark: Generated from `#/paths//Audio/{Id}/universal/get(getAudioByIdUniversal)`.
    internal func getAudioByIdUniversal(_ input: Operations.getAudioByIdUniversal.Input) async throws -> Operations.getAudioByIdUniversal.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAudioByIdUniversal.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Audio/{}/universal",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartTimeTicks",
                    value: input.query.StartTimeTicks
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets an audio stream
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Audio/{Id}/universal`.
    /// - Remark: Generated from `#/paths//Audio/{Id}/universal/head(headAudioByIdUniversal)`.
    internal func headAudioByIdUniversal(_ input: Operations.headAudioByIdUniversal.Input) async throws -> Operations.headAudioByIdUniversal.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headAudioByIdUniversal.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Audio/{}/universal",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartTimeTicks",
                    value: input.query.StartTimeTicks
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets an audio stream
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Audio/{Id}/stream.{Container}`.
    /// - Remark: Generated from `#/paths//Audio/{Id}/stream.{Container}/get(getAudioByIdStreamByContainer)`.
    internal func getAudioByIdStreamByContainer(_ input: Operations.getAudioByIdStreamByContainer.Input) async throws -> Operations.getAudioByIdStreamByContainer.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAudioByIdStreamByContainer.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Audio/{}/stream.{}",
                    parameters: [
                        input.path.Id,
                        input.path.Container
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceProfileId",
                    value: input.query.DeviceProfileId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioCodec",
                    value: input.query.AudioCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableAutoStreamCopy",
                    value: input.query.EnableAutoStreamCopy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioSampleRate",
                    value: input.query.AudioSampleRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioBitRate",
                    value: input.query.AudioBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioChannels",
                    value: input.query.AudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxAudioChannels",
                    value: input.query.MaxAudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Static",
                    value: input.query.Static
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartTimeTicks",
                    value: input.query.StartTimeTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoBitRate",
                    value: input.query.VideoBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleStreamIndex",
                    value: input.query.SubtitleStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleMethod",
                    value: input.query.SubtitleMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxVideoBitDepth",
                    value: input.query.MaxVideoBitDepth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoCodec",
                    value: input.query.VideoCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioStreamIndex",
                    value: input.query.AudioStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoStreamIndex",
                    value: input.query.VideoStreamIndex
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets an audio stream
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Audio/{Id}/stream.{Container}`.
    /// - Remark: Generated from `#/paths//Audio/{Id}/stream.{Container}/head(headAudioByIdStreamByContainer)`.
    internal func headAudioByIdStreamByContainer(_ input: Operations.headAudioByIdStreamByContainer.Input) async throws -> Operations.headAudioByIdStreamByContainer.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headAudioByIdStreamByContainer.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Audio/{}/stream.{}",
                    parameters: [
                        input.path.Id,
                        input.path.Container
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceProfileId",
                    value: input.query.DeviceProfileId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioCodec",
                    value: input.query.AudioCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableAutoStreamCopy",
                    value: input.query.EnableAutoStreamCopy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioSampleRate",
                    value: input.query.AudioSampleRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioBitRate",
                    value: input.query.AudioBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioChannels",
                    value: input.query.AudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxAudioChannels",
                    value: input.query.MaxAudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Static",
                    value: input.query.Static
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartTimeTicks",
                    value: input.query.StartTimeTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoBitRate",
                    value: input.query.VideoBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleStreamIndex",
                    value: input.query.SubtitleStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleMethod",
                    value: input.query.SubtitleMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxVideoBitDepth",
                    value: input.query.MaxVideoBitDepth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoCodec",
                    value: input.query.VideoCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioStreamIndex",
                    value: input.query.AudioStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoStreamIndex",
                    value: input.query.VideoStreamIndex
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets an audio stream
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Audio/{Id}/stream`.
    /// - Remark: Generated from `#/paths//Audio/{Id}/stream/get(getAudioByIdStream)`.
    internal func getAudioByIdStream(_ input: Operations.getAudioByIdStream.Input) async throws -> Operations.getAudioByIdStream.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAudioByIdStream.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Audio/{}/stream",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceProfileId",
                    value: input.query.DeviceProfileId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Container",
                    value: input.query.Container
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioCodec",
                    value: input.query.AudioCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableAutoStreamCopy",
                    value: input.query.EnableAutoStreamCopy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioSampleRate",
                    value: input.query.AudioSampleRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioBitRate",
                    value: input.query.AudioBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioChannels",
                    value: input.query.AudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxAudioChannels",
                    value: input.query.MaxAudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Static",
                    value: input.query.Static
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartTimeTicks",
                    value: input.query.StartTimeTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoBitRate",
                    value: input.query.VideoBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleStreamIndex",
                    value: input.query.SubtitleStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleMethod",
                    value: input.query.SubtitleMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxVideoBitDepth",
                    value: input.query.MaxVideoBitDepth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoCodec",
                    value: input.query.VideoCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioStreamIndex",
                    value: input.query.AudioStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoStreamIndex",
                    value: input.query.VideoStreamIndex
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets an audio stream
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Audio/{Id}/stream`.
    /// - Remark: Generated from `#/paths//Audio/{Id}/stream/head(headAudioByIdStream)`.
    internal func headAudioByIdStream(_ input: Operations.headAudioByIdStream.Input) async throws -> Operations.headAudioByIdStream.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headAudioByIdStream.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Audio/{}/stream",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceProfileId",
                    value: input.query.DeviceProfileId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Container",
                    value: input.query.Container
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioCodec",
                    value: input.query.AudioCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableAutoStreamCopy",
                    value: input.query.EnableAutoStreamCopy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioSampleRate",
                    value: input.query.AudioSampleRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioBitRate",
                    value: input.query.AudioBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioChannels",
                    value: input.query.AudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxAudioChannels",
                    value: input.query.MaxAudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Static",
                    value: input.query.Static
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartTimeTicks",
                    value: input.query.StartTimeTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoBitRate",
                    value: input.query.VideoBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleStreamIndex",
                    value: input.query.SubtitleStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleMethod",
                    value: input.query.SubtitleMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxVideoBitDepth",
                    value: input.query.MaxVideoBitDepth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoCodec",
                    value: input.query.VideoCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioStreamIndex",
                    value: input.query.AudioStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoStreamIndex",
                    value: input.query.VideoStreamIndex
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets an audio stream
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Audio/{Id}/{StreamFileName}`.
    /// - Remark: Generated from `#/paths//Audio/{Id}/{StreamFileName}/get(getAudioByIdByStreamfilename)`.
    internal func getAudioByIdByStreamfilename(_ input: Operations.getAudioByIdByStreamfilename.Input) async throws -> Operations.getAudioByIdByStreamfilename.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAudioByIdByStreamfilename.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Audio/{}/{}",
                    parameters: [
                        input.path.Id,
                        input.path.StreamFileName
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceProfileId",
                    value: input.query.DeviceProfileId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Container",
                    value: input.query.Container
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioCodec",
                    value: input.query.AudioCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableAutoStreamCopy",
                    value: input.query.EnableAutoStreamCopy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioSampleRate",
                    value: input.query.AudioSampleRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioBitRate",
                    value: input.query.AudioBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioChannels",
                    value: input.query.AudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxAudioChannels",
                    value: input.query.MaxAudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Static",
                    value: input.query.Static
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartTimeTicks",
                    value: input.query.StartTimeTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoBitRate",
                    value: input.query.VideoBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleStreamIndex",
                    value: input.query.SubtitleStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleMethod",
                    value: input.query.SubtitleMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxVideoBitDepth",
                    value: input.query.MaxVideoBitDepth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoCodec",
                    value: input.query.VideoCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioStreamIndex",
                    value: input.query.AudioStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoStreamIndex",
                    value: input.query.VideoStreamIndex
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets an audio stream
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Audio/{Id}/{StreamFileName}`.
    /// - Remark: Generated from `#/paths//Audio/{Id}/{StreamFileName}/head(headAudioByIdByStreamfilename)`.
    internal func headAudioByIdByStreamfilename(_ input: Operations.headAudioByIdByStreamfilename.Input) async throws -> Operations.headAudioByIdByStreamfilename.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headAudioByIdByStreamfilename.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Audio/{}/{}",
                    parameters: [
                        input.path.Id,
                        input.path.StreamFileName
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceProfileId",
                    value: input.query.DeviceProfileId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Container",
                    value: input.query.Container
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioCodec",
                    value: input.query.AudioCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableAutoStreamCopy",
                    value: input.query.EnableAutoStreamCopy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioSampleRate",
                    value: input.query.AudioSampleRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioBitRate",
                    value: input.query.AudioBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioChannels",
                    value: input.query.AudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxAudioChannels",
                    value: input.query.MaxAudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Static",
                    value: input.query.Static
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartTimeTicks",
                    value: input.query.StartTimeTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoBitRate",
                    value: input.query.VideoBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleStreamIndex",
                    value: input.query.SubtitleStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleMethod",
                    value: input.query.SubtitleMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxVideoBitDepth",
                    value: input.query.MaxVideoBitDepth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoCodec",
                    value: input.query.VideoCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioStreamIndex",
                    value: input.query.AudioStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoStreamIndex",
                    value: input.query.VideoStreamIndex
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets an audio stream using HTTP live streaming.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Audio/{Id}/master.m3u8`.
    /// - Remark: Generated from `#/paths//Audio/{Id}/master.m3u8/get(getAudioByIdMasterM3u8)`.
    internal func getAudioByIdMasterM3u8(_ input: Operations.getAudioByIdMasterM3u8.Input) async throws -> Operations.getAudioByIdMasterM3u8.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAudioByIdMasterM3u8.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Audio/{}/master.m3u8",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceProfileId",
                    value: input.query.DeviceProfileId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Container",
                    value: input.query.Container
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioCodec",
                    value: input.query.AudioCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableAutoStreamCopy",
                    value: input.query.EnableAutoStreamCopy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioSampleRate",
                    value: input.query.AudioSampleRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioBitRate",
                    value: input.query.AudioBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioChannels",
                    value: input.query.AudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxAudioChannels",
                    value: input.query.MaxAudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Static",
                    value: input.query.Static
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartTimeTicks",
                    value: input.query.StartTimeTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoBitRate",
                    value: input.query.VideoBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleStreamIndex",
                    value: input.query.SubtitleStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleMethod",
                    value: input.query.SubtitleMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxVideoBitDepth",
                    value: input.query.MaxVideoBitDepth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoCodec",
                    value: input.query.VideoCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioStreamIndex",
                    value: input.query.AudioStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoStreamIndex",
                    value: input.query.VideoStreamIndex
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets an audio stream using HTTP live streaming.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Audio/{Id}/master.m3u8`.
    /// - Remark: Generated from `#/paths//Audio/{Id}/master.m3u8/head(headAudioByIdMasterM3u8)`.
    internal func headAudioByIdMasterM3u8(_ input: Operations.headAudioByIdMasterM3u8.Input) async throws -> Operations.headAudioByIdMasterM3u8.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headAudioByIdMasterM3u8.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Audio/{}/master.m3u8",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceProfileId",
                    value: input.query.DeviceProfileId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Container",
                    value: input.query.Container
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioCodec",
                    value: input.query.AudioCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableAutoStreamCopy",
                    value: input.query.EnableAutoStreamCopy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioSampleRate",
                    value: input.query.AudioSampleRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioBitRate",
                    value: input.query.AudioBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioChannels",
                    value: input.query.AudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxAudioChannels",
                    value: input.query.MaxAudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Static",
                    value: input.query.Static
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartTimeTicks",
                    value: input.query.StartTimeTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoBitRate",
                    value: input.query.VideoBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleStreamIndex",
                    value: input.query.SubtitleStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleMethod",
                    value: input.query.SubtitleMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxVideoBitDepth",
                    value: input.query.MaxVideoBitDepth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoCodec",
                    value: input.query.VideoCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioStreamIndex",
                    value: input.query.AudioStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoStreamIndex",
                    value: input.query.VideoStreamIndex
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Audio/{Id}/live.m3u8`.
    /// - Remark: Generated from `#/paths//Audio/{Id}/live.m3u8/get(getAudioByIdLiveM3u8)`.
    internal func getAudioByIdLiveM3u8(_ input: Operations.getAudioByIdLiveM3u8.Input) async throws -> Operations.getAudioByIdLiveM3u8.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAudioByIdLiveM3u8.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Audio/{}/live.m3u8",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceProfileId",
                    value: input.query.DeviceProfileId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Container",
                    value: input.query.Container
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioCodec",
                    value: input.query.AudioCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableAutoStreamCopy",
                    value: input.query.EnableAutoStreamCopy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioSampleRate",
                    value: input.query.AudioSampleRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioBitRate",
                    value: input.query.AudioBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioChannels",
                    value: input.query.AudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxAudioChannels",
                    value: input.query.MaxAudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Static",
                    value: input.query.Static
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartTimeTicks",
                    value: input.query.StartTimeTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoBitRate",
                    value: input.query.VideoBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleStreamIndex",
                    value: input.query.SubtitleStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleMethod",
                    value: input.query.SubtitleMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxVideoBitDepth",
                    value: input.query.MaxVideoBitDepth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoCodec",
                    value: input.query.VideoCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioStreamIndex",
                    value: input.query.AudioStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoStreamIndex",
                    value: input.query.VideoStreamIndex
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets an audio stream using HTTP live streaming.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Audio/{Id}/main.m3u8`.
    /// - Remark: Generated from `#/paths//Audio/{Id}/main.m3u8/get(getAudioByIdMainM3u8)`.
    internal func getAudioByIdMainM3u8(_ input: Operations.getAudioByIdMainM3u8.Input) async throws -> Operations.getAudioByIdMainM3u8.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAudioByIdMainM3u8.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Audio/{}/main.m3u8",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceProfileId",
                    value: input.query.DeviceProfileId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Container",
                    value: input.query.Container
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioCodec",
                    value: input.query.AudioCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableAutoStreamCopy",
                    value: input.query.EnableAutoStreamCopy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioSampleRate",
                    value: input.query.AudioSampleRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioBitRate",
                    value: input.query.AudioBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioChannels",
                    value: input.query.AudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxAudioChannels",
                    value: input.query.MaxAudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Static",
                    value: input.query.Static
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartTimeTicks",
                    value: input.query.StartTimeTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoBitRate",
                    value: input.query.VideoBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleStreamIndex",
                    value: input.query.SubtitleStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleMethod",
                    value: input.query.SubtitleMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxVideoBitDepth",
                    value: input.query.MaxVideoBitDepth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoCodec",
                    value: input.query.VideoCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioStreamIndex",
                    value: input.query.AudioStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoStreamIndex",
                    value: input.query.VideoStreamIndex
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `DELETE /Auth/Keys/{Key}`.
    /// - Remark: Generated from `#/paths//Auth/Keys/{Key}/delete(deleteAuthKeysByKey)`.
    internal func deleteAuthKeysByKey(_ input: Operations.deleteAuthKeysByKey.Input) async throws -> Operations.deleteAuthKeysByKey.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteAuthKeysByKey.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Auth/Keys/{}",
                    parameters: [
                        input.path.Key
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Adds items to a collection
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Collections/{Id}/Items`.
    /// - Remark: Generated from `#/paths//Collections/{Id}/Items/post(postCollectionsByIdItems)`.
    internal func postCollectionsByIdItems(_ input: Operations.postCollectionsByIdItems.Input) async throws -> Operations.postCollectionsByIdItems.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postCollectionsByIdItems.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Collections/{}/Items",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Ids",
                    value: input.query.Ids
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Removes items from a collection
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `DELETE /Collections/{Id}/Items`.
    /// - Remark: Generated from `#/paths//Collections/{Id}/Items/delete(deleteCollectionsByIdItems)`.
    internal func deleteCollectionsByIdItems(_ input: Operations.deleteCollectionsByIdItems.Input) async throws -> Operations.deleteCollectionsByIdItems.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteCollectionsByIdItems.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Collections/{}/Items",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Ids",
                    value: input.query.Ids
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets dlna server info
    ///
    /// No authentication required
    ///
    /// - Remark: HTTP `GET /Dlna/{UuId}/description.xml`.
    /// - Remark: Generated from `#/paths//Dlna/{UuId}/description.xml/get(getDlnaByUuidDescriptionXml)`.
    internal func getDlnaByUuidDescriptionXml(_ input: Operations.getDlnaByUuidDescriptionXml.Input) async throws -> Operations.getDlnaByUuidDescriptionXml.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getDlnaByUuidDescriptionXml.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Dlna/{}/description.xml",
                    parameters: [
                        input.path.UuId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets dlna server info
    ///
    /// No authentication required
    ///
    /// - Remark: HTTP `HEAD /Dlna/{UuId}/description.xml`.
    /// - Remark: Generated from `#/paths//Dlna/{UuId}/description.xml/head(headDlnaByUuidDescriptionXml)`.
    internal func headDlnaByUuidDescriptionXml(_ input: Operations.headDlnaByUuidDescriptionXml.Input) async throws -> Operations.headDlnaByUuidDescriptionXml.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headDlnaByUuidDescriptionXml.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Dlna/{}/description.xml",
                    parameters: [
                        input.path.UuId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets dlna server info
    ///
    /// No authentication required
    ///
    /// - Remark: HTTP `GET /Dlna/{UuId}/description`.
    /// - Remark: Generated from `#/paths//Dlna/{UuId}/description/get(getDlnaByUuidDescription)`.
    internal func getDlnaByUuidDescription(_ input: Operations.getDlnaByUuidDescription.Input) async throws -> Operations.getDlnaByUuidDescription.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getDlnaByUuidDescription.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Dlna/{}/description",
                    parameters: [
                        input.path.UuId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets dlna server info
    ///
    /// No authentication required
    ///
    /// - Remark: HTTP `HEAD /Dlna/{UuId}/description`.
    /// - Remark: Generated from `#/paths//Dlna/{UuId}/description/head(headDlnaByUuidDescription)`.
    internal func headDlnaByUuidDescription(_ input: Operations.headDlnaByUuidDescription.Input) async throws -> Operations.headDlnaByUuidDescription.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headDlnaByUuidDescription.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Dlna/{}/description",
                    parameters: [
                        input.path.UuId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a server icon
    ///
    /// No authentication required
    ///
    /// - Remark: HTTP `GET /Dlna/icons/{Filename}`.
    /// - Remark: Generated from `#/paths//Dlna/icons/{Filename}/get(getDlnaIconsByFilename)`.
    internal func getDlnaIconsByFilename(_ input: Operations.getDlnaIconsByFilename.Input) async throws -> Operations.getDlnaIconsByFilename.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getDlnaIconsByFilename.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Dlna/icons/{}",
                    parameters: [
                        input.path.Filename
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UuId",
                    value: input.query.UuId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a single profile
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Dlna/Profiles/{Id}`.
    /// - Remark: Generated from `#/paths//Dlna/Profiles/{Id}/get(getDlnaProfilesById)`.
    internal func getDlnaProfilesById(_ input: Operations.getDlnaProfilesById.Input) async throws -> Operations.getDlnaProfilesById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getDlnaProfilesById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Dlna/Profiles/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getDlnaProfilesById.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Dlna_period_Profiles_period_DlnaProfile.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates a profile
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Dlna/Profiles/{Id}`.
    /// - Remark: Generated from `#/paths//Dlna/Profiles/{Id}/post(postDlnaProfilesById)`.
    internal func postDlnaProfilesById(_ input: Operations.postDlnaProfilesById.Input) async throws -> Operations.postDlnaProfilesById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postDlnaProfilesById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Dlna/Profiles/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deletes a profile
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `DELETE /Dlna/Profiles/{Id}`.
    /// - Remark: Generated from `#/paths//Dlna/Profiles/{Id}/delete(deleteDlnaProfilesById)`.
    internal func deleteDlnaProfilesById(_ input: Operations.deleteDlnaProfilesById.Input) async throws -> Operations.deleteDlnaProfilesById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteDlnaProfilesById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Dlna/Profiles/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets the default profile
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Dlna/Profiles/Default`.
    /// - Remark: Generated from `#/paths//Dlna/Profiles/Default/get(getDlnaProfilesDefault)`.
    internal func getDlnaProfilesDefault(_ input: Operations.getDlnaProfilesDefault.Input) async throws -> Operations.getDlnaProfilesDefault.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getDlnaProfilesDefault.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Dlna/Profiles/Default",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getDlnaProfilesDefault.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Dlna_period_Profiles_period_DlnaProfile.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets details about available video encoders and decoders
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Encoding/CodecInformation/Video`.
    /// - Remark: Generated from `#/paths//Encoding/CodecInformation/Video/get(getEncodingCodecinformationVideo)`.
    internal func getEncodingCodecinformationVideo(_ input: Operations.getEncodingCodecinformationVideo.Input) async throws -> Operations.getEncodingCodecinformationVideo.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getEncodingCodecinformationVideo.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Encoding/CodecInformation/Video",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getEncodingCodecinformationVideo.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.VideoCodecBase].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets default codec configurations
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Encoding/CodecConfiguration/Defaults`.
    /// - Remark: Generated from `#/paths//Encoding/CodecConfiguration/Defaults/get(getEncodingCodecconfigurationDefaults)`.
    internal func getEncodingCodecconfigurationDefaults(_ input: Operations.getEncodingCodecconfigurationDefaults.Input) async throws -> Operations.getEncodingCodecconfigurationDefaults.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getEncodingCodecconfigurationDefaults.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Encoding/CodecConfiguration/Defaults",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getEncodingCodecconfigurationDefaults.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.CodecConfiguration].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Finds games similar to a given game.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Games/{Id}/Similar`.
    /// - Remark: Generated from `#/paths//Games/{Id}/Similar/get(getGamesByIdSimilar)`.
    internal func getGamesByIdSimilar(_ input: Operations.getGamesByIdSimilar.Input) async throws -> Operations.getGamesByIdSimilar.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getGamesByIdSimilar.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Games/{}/Similar",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getGamesByIdSimilar.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets external id infos for an item
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Items/{Id}/ExternalIdInfos`.
    /// - Remark: Generated from `#/paths//Items/{Id}/ExternalIdInfos/get(getItemsByIdExternalidinfos)`.
    internal func getItemsByIdExternalidinfos(_ input: Operations.getItemsByIdExternalidinfos.Input) async throws -> Operations.getItemsByIdExternalidinfos.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsByIdExternalidinfos.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/ExternalIdInfos",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItemsByIdExternalidinfos.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.ExternalIdInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Items/RemoteSearch/Trailer`.
    /// - Remark: Generated from `#/paths//Items/RemoteSearch/Trailer/post(postItemsRemotesearchTrailer)`.
    internal func postItemsRemotesearchTrailer(_ input: Operations.postItemsRemotesearchTrailer.Input) async throws -> Operations.postItemsRemotesearchTrailer.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsRemotesearchTrailer.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/RemoteSearch/Trailer",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postItemsRemotesearchTrailer.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.RemoteSearchResult].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Items/RemoteSearch/Book`.
    /// - Remark: Generated from `#/paths//Items/RemoteSearch/Book/post(postItemsRemotesearchBook)`.
    internal func postItemsRemotesearchBook(_ input: Operations.postItemsRemotesearchBook.Input) async throws -> Operations.postItemsRemotesearchBook.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsRemotesearchBook.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/RemoteSearch/Book",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postItemsRemotesearchBook.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.RemoteSearchResult].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Items/RemoteSearch/Movie`.
    /// - Remark: Generated from `#/paths//Items/RemoteSearch/Movie/post(postItemsRemotesearchMovie)`.
    internal func postItemsRemotesearchMovie(_ input: Operations.postItemsRemotesearchMovie.Input) async throws -> Operations.postItemsRemotesearchMovie.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsRemotesearchMovie.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/RemoteSearch/Movie",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postItemsRemotesearchMovie.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.RemoteSearchResult].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Items/RemoteSearch/Series`.
    /// - Remark: Generated from `#/paths//Items/RemoteSearch/Series/post(postItemsRemotesearchSeries)`.
    internal func postItemsRemotesearchSeries(_ input: Operations.postItemsRemotesearchSeries.Input) async throws -> Operations.postItemsRemotesearchSeries.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsRemotesearchSeries.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/RemoteSearch/Series",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postItemsRemotesearchSeries.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.RemoteSearchResult].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Items/RemoteSearch/Game`.
    /// - Remark: Generated from `#/paths//Items/RemoteSearch/Game/post(postItemsRemotesearchGame)`.
    internal func postItemsRemotesearchGame(_ input: Operations.postItemsRemotesearchGame.Input) async throws -> Operations.postItemsRemotesearchGame.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsRemotesearchGame.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/RemoteSearch/Game",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postItemsRemotesearchGame.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.RemoteSearchResult].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Items/RemoteSearch/BoxSet`.
    /// - Remark: Generated from `#/paths//Items/RemoteSearch/BoxSet/post(postItemsRemotesearchBoxset)`.
    internal func postItemsRemotesearchBoxset(_ input: Operations.postItemsRemotesearchBoxset.Input) async throws -> Operations.postItemsRemotesearchBoxset.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsRemotesearchBoxset.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/RemoteSearch/BoxSet",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postItemsRemotesearchBoxset.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.RemoteSearchResult].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Items/RemoteSearch/MusicVideo`.
    /// - Remark: Generated from `#/paths//Items/RemoteSearch/MusicVideo/post(postItemsRemotesearchMusicvideo)`.
    internal func postItemsRemotesearchMusicvideo(_ input: Operations.postItemsRemotesearchMusicvideo.Input) async throws -> Operations.postItemsRemotesearchMusicvideo.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsRemotesearchMusicvideo.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/RemoteSearch/MusicVideo",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postItemsRemotesearchMusicvideo.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.RemoteSearchResult].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Items/RemoteSearch/Person`.
    /// - Remark: Generated from `#/paths//Items/RemoteSearch/Person/post(postItemsRemotesearchPerson)`.
    internal func postItemsRemotesearchPerson(_ input: Operations.postItemsRemotesearchPerson.Input) async throws -> Operations.postItemsRemotesearchPerson.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsRemotesearchPerson.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/RemoteSearch/Person",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postItemsRemotesearchPerson.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.RemoteSearchResult].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Items/RemoteSearch/MusicAlbum`.
    /// - Remark: Generated from `#/paths//Items/RemoteSearch/MusicAlbum/post(postItemsRemotesearchMusicalbum)`.
    internal func postItemsRemotesearchMusicalbum(_ input: Operations.postItemsRemotesearchMusicalbum.Input) async throws -> Operations.postItemsRemotesearchMusicalbum.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsRemotesearchMusicalbum.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/RemoteSearch/MusicAlbum",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postItemsRemotesearchMusicalbum.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.RemoteSearchResult].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Items/RemoteSearch/MusicArtist`.
    /// - Remark: Generated from `#/paths//Items/RemoteSearch/MusicArtist/post(postItemsRemotesearchMusicartist)`.
    internal func postItemsRemotesearchMusicartist(_ input: Operations.postItemsRemotesearchMusicartist.Input) async throws -> Operations.postItemsRemotesearchMusicartist.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsRemotesearchMusicartist.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/RemoteSearch/MusicArtist",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postItemsRemotesearchMusicartist.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.RemoteSearchResult].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a remote image
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Items/RemoteSearch/Image`.
    /// - Remark: Generated from `#/paths//Items/RemoteSearch/Image/get(getItemsRemotesearchImage)`.
    internal func getItemsRemotesearchImage(_ input: Operations.getItemsRemotesearchImage.Input) async throws -> Operations.getItemsRemotesearchImage.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsRemotesearchImage.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/RemoteSearch/Image",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageUrl",
                    value: input.query.ImageUrl
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProviderName",
                    value: input.query.ProviderName
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Resets metadata for one or more items
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Items/Metadata/Reset`.
    /// - Remark: Generated from `#/paths//Items/Metadata/Reset/post(postItemsMetadataReset)`.
    internal func postItemsMetadataReset(_ input: Operations.postItemsMetadataReset.Input) async throws -> Operations.postItemsMetadataReset.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsMetadataReset.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/Metadata/Reset",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ItemIds",
                    value: input.query.ItemIds
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Refreshes metadata for an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Items/{Id}/Refresh`.
    /// - Remark: Generated from `#/paths//Items/{Id}/Refresh/post(postItemsByIdRefresh)`.
    internal func postItemsByIdRefresh(_ input: Operations.postItemsByIdRefresh.Input) async throws -> Operations.postItemsByIdRefresh.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsByIdRefresh.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/Refresh",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MetadataRefreshMode",
                    value: input.query.MetadataRefreshMode
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageRefreshMode",
                    value: input.query.ImageRefreshMode
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ReplaceAllMetadata",
                    value: input.query.ReplaceAllMetadata
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ReplaceAllImages",
                    value: input.query.ReplaceAllImages
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets metadata editor info for an item
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Items/{ItemId}/MetadataEditor`.
    /// - Remark: Generated from `#/paths//Items/{ItemId}/MetadataEditor/get(getItemsByItemidMetadataeditor)`.
    internal func getItemsByItemidMetadataeditor(_ input: Operations.getItemsByItemidMetadataeditor.Input) async throws -> Operations.getItemsByItemidMetadataeditor.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsByItemidMetadataeditor.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/MetadataEditor",
                    parameters: [
                        input.path.ItemId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItemsByItemidMetadataeditor.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.MetadataEditorInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Makes an item public to all users
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Items/{Id}/MakePublic`.
    /// - Remark: Generated from `#/paths//Items/{Id}/MakePublic/post(postItemsByIdMakepublic)`.
    internal func postItemsByIdMakepublic(_ input: Operations.postItemsByIdMakepublic.Input) async throws -> Operations.postItemsByIdMakepublic.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsByIdMakepublic.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/MakePublic",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Makes an item private
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Items/{Id}/MakePrivate`.
    /// - Remark: Generated from `#/paths//Items/{Id}/MakePrivate/post(postItemsByIdMakeprivate)`.
    internal func postItemsByIdMakeprivate(_ input: Operations.postItemsByIdMakeprivate.Input) async throws -> Operations.postItemsByIdMakeprivate.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsByIdMakeprivate.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/MakePrivate",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Leaves a shared item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Items/Shared/Leave`.
    /// - Remark: Generated from `#/paths//Items/Shared/Leave/post(postItemsSharedLeave)`.
    internal func postItemsSharedLeave(_ input: Operations.postItemsSharedLeave.Input) async throws -> Operations.postItemsSharedLeave.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsSharedLeave.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/Shared/Leave",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Creates an instant playlist based on a given item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Items/{Id}/InstantMix`.
    /// - Remark: Generated from `#/paths//Items/{Id}/InstantMix/get(getItemsByIdInstantmix)`.
    internal func getItemsByIdInstantmix(_ input: Operations.getItemsByIdInstantmix.Input) async throws -> Operations.getItemsByIdInstantmix.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsByIdInstantmix.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/InstantMix",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItemsByIdInstantmix.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets delete info for an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Items/{Id}/DeleteInfo`.
    /// - Remark: Generated from `#/paths//Items/{Id}/DeleteInfo/get(getItemsByIdDeleteinfo)`.
    internal func getItemsByIdDeleteinfo(_ input: Operations.getItemsByIdDeleteinfo.Input) async throws -> Operations.getItemsByIdDeleteinfo.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsByIdDeleteinfo.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/DeleteInfo",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItemsByIdDeleteinfo.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Library_period_DeleteInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets similar items
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Items/{Id}/Similar`.
    /// - Remark: Generated from `#/paths//Items/{Id}/Similar/get(getItemsByIdSimilar)`.
    internal func getItemsByIdSimilar(_ input: Operations.getItemsByIdSimilar.Input) async throws -> Operations.getItemsByIdSimilar.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsByIdSimilar.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/Similar",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItemsByIdSimilar.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Downloads item media
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Items/{Id}/Download`.
    /// - Remark: Generated from `#/paths//Items/{Id}/Download/get(getItemsByIdDownload)`.
    internal func getItemsByIdDownload(_ input: Operations.getItemsByIdDownload.Input) async throws -> Operations.getItemsByIdDownload.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsByIdDownload.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/Download",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets the original file of an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Items/{Id}/File`.
    /// - Remark: Generated from `#/paths//Items/{Id}/File/get(getItemsByIdFile)`.
    internal func getItemsByIdFile(_ input: Operations.getItemsByIdFile.Input) async throws -> Operations.getItemsByIdFile.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsByIdFile.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/File",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets all parents of an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Items/{Id}/Ancestors`.
    /// - Remark: Generated from `#/paths//Items/{Id}/Ancestors/get(getItemsByIdAncestors)`.
    internal func getItemsByIdAncestors(_ input: Operations.getItemsByIdAncestors.Input) async throws -> Operations.getItemsByIdAncestors.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsByIdAncestors.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/Ancestors",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItemsByIdAncestors.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.BaseItemDto].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets critic reviews for an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Items/{Id}/CriticReviews`.
    /// - Remark: Generated from `#/paths//Items/{Id}/CriticReviews/get(getItemsByIdCriticreviews)`.
    internal func getItemsByIdCriticreviews(_ input: Operations.getItemsByIdCriticreviews.Input) async throws -> Operations.getItemsByIdCriticreviews.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsByIdCriticreviews.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/CriticReviews",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItemsByIdCriticreviews.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deletes an item from the library and file system
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Items/{Id}/Delete`.
    /// - Remark: Generated from `#/paths//Items/{Id}/Delete/post(postItemsByIdDelete)`.
    internal func postItemsByIdDelete(_ input: Operations.postItemsByIdDelete.Input) async throws -> Operations.postItemsByIdDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsByIdDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/Delete",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets theme videos and songs for an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Items/{Id}/ThemeMedia`.
    /// - Remark: Generated from `#/paths//Items/{Id}/ThemeMedia/get(getItemsByIdThememedia)`.
    internal func getItemsByIdThememedia(_ input: Operations.getItemsByIdThememedia.Input) async throws -> Operations.getItemsByIdThememedia.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsByIdThememedia.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/ThemeMedia",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "InheritFromParent",
                    value: input.query.InheritFromParent
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItemsByIdThememedia.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AllThemeMediaResult.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets theme songs for an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Items/{Id}/ThemeSongs`.
    /// - Remark: Generated from `#/paths//Items/{Id}/ThemeSongs/get(getItemsByIdThemesongs)`.
    internal func getItemsByIdThemesongs(_ input: Operations.getItemsByIdThemesongs.Input) async throws -> Operations.getItemsByIdThemesongs.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsByIdThemesongs.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/ThemeSongs",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "InheritFromParent",
                    value: input.query.InheritFromParent
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItemsByIdThemesongs.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ThemeMediaResult.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets theme videos for an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Items/{Id}/ThemeVideos`.
    /// - Remark: Generated from `#/paths//Items/{Id}/ThemeVideos/get(getItemsByIdThemevideos)`.
    internal func getItemsByIdThemevideos(_ input: Operations.getItemsByIdThemevideos.Input) async throws -> Operations.getItemsByIdThemevideos.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsByIdThemevideos.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/ThemeVideos",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "InheritFromParent",
                    value: input.query.InheritFromParent
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItemsByIdThemevideos.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ThemeMediaResult.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets information about an item's images
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Items/{Id}/Images`.
    /// - Remark: Generated from `#/paths//Items/{Id}/Images/get(getItemsByIdImages)`.
    internal func getItemsByIdImages(_ input: Operations.getItemsByIdImages.Input) async throws -> Operations.getItemsByIdImages.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsByIdImages.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/Images",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItemsByIdImages.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.ImageInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets available remote images for an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Items/{Id}/RemoteImages`.
    /// - Remark: Generated from `#/paths//Items/{Id}/RemoteImages/get(getItemsByIdRemoteimages)`.
    internal func getItemsByIdRemoteimages(_ input: Operations.getItemsByIdRemoteimages.Input) async throws -> Operations.getItemsByIdRemoteimages.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsByIdRemoteimages.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/RemoteImages",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Type",
                    value: input.query._Type
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProviderName",
                    value: input.query.ProviderName
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IncludeAllLanguages",
                    value: input.query.IncludeAllLanguages
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItemsByIdRemoteimages.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.RemoteImageResult.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Items/{Id}/ThumbnailSet`.
    /// - Remark: Generated from `#/paths//Items/{Id}/ThumbnailSet/get(getItemsByIdThumbnailset)`.
    internal func getItemsByIdThumbnailset(_ input: Operations.getItemsByIdThumbnailset.Input) async throws -> Operations.getItemsByIdThumbnailset.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsByIdThumbnailset.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/ThumbnailSet",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItemsByIdThumbnailset.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.RokuMetadata_period_Api_period_ThumbnailSetInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets live playback media info for an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Items/{Id}/PlaybackInfo`.
    /// - Remark: Generated from `#/paths//Items/{Id}/PlaybackInfo/get(getItemsByIdPlaybackinfo)`.
    internal func getItemsByIdPlaybackinfo(_ input: Operations.getItemsByIdPlaybackinfo.Input) async throws -> Operations.getItemsByIdPlaybackinfo.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsByIdPlaybackinfo.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/PlaybackInfo",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItemsByIdPlaybackinfo.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PlaybackInfoResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets live playback media info for an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Items/{Id}/PlaybackInfo`.
    /// - Remark: Generated from `#/paths//Items/{Id}/PlaybackInfo/post(postItemsByIdPlaybackinfo)`.
    internal func postItemsByIdPlaybackinfo(_ input: Operations.postItemsByIdPlaybackinfo.Input) async throws -> Operations.postItemsByIdPlaybackinfo.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsByIdPlaybackinfo.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/PlaybackInfo",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postItemsByIdPlaybackinfo.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PlaybackInfoResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deprecated. Use /Library/Media/Updated
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Library/Series/Added`.
    /// - Remark: Generated from `#/paths//Library/Series/Added/post(postLibrarySeriesAdded)`.
    internal func postLibrarySeriesAdded(_ input: Operations.postLibrarySeriesAdded.Input) async throws -> Operations.postLibrarySeriesAdded.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLibrarySeriesAdded.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Library/Series/Added",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deprecated. Use /Library/Media/Updated
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Library/Series/Updated`.
    /// - Remark: Generated from `#/paths//Library/Series/Updated/post(postLibrarySeriesUpdated)`.
    internal func postLibrarySeriesUpdated(_ input: Operations.postLibrarySeriesUpdated.Input) async throws -> Operations.postLibrarySeriesUpdated.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLibrarySeriesUpdated.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Library/Series/Updated",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Reports that new movies have been added by an external source
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Library/Media/Updated`.
    /// - Remark: Generated from `#/paths//Library/Media/Updated/post(postLibraryMediaUpdated)`.
    internal func postLibraryMediaUpdated(_ input: Operations.postLibraryMediaUpdated.Input) async throws -> Operations.postLibraryMediaUpdated.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLibraryMediaUpdated.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Library/Media/Updated",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deprecated. Use /Library/Media/Updated
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Library/Movies/Added`.
    /// - Remark: Generated from `#/paths//Library/Movies/Added/post(postLibraryMoviesAdded)`.
    internal func postLibraryMoviesAdded(_ input: Operations.postLibraryMoviesAdded.Input) async throws -> Operations.postLibraryMoviesAdded.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLibraryMoviesAdded.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Library/Movies/Added",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deprecated. Use /Library/Media/Updated
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Library/Movies/Updated`.
    /// - Remark: Generated from `#/paths//Library/Movies/Updated/post(postLibraryMoviesUpdated)`.
    internal func postLibraryMoviesUpdated(_ input: Operations.postLibraryMoviesUpdated.Input) async throws -> Operations.postLibraryMoviesUpdated.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLibraryMoviesUpdated.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Library/Movies/Updated",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Library/VirtualFolders/Query`.
    /// - Remark: Generated from `#/paths//Library/VirtualFolders/Query/get(getLibraryVirtualfoldersQuery)`.
    internal func getLibraryVirtualfoldersQuery(_ input: Operations.getLibraryVirtualfoldersQuery.Input) async throws -> Operations.getLibraryVirtualfoldersQuery.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLibraryVirtualfoldersQuery.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Library/VirtualFolders/Query",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLibraryVirtualfoldersQuery.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_VirtualFolderInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Library/VirtualFolders/LibraryOptions`.
    /// - Remark: Generated from `#/paths//Library/VirtualFolders/LibraryOptions/post(postLibraryVirtualfoldersLibraryoptions)`.
    internal func postLibraryVirtualfoldersLibraryoptions(_ input: Operations.postLibraryVirtualfoldersLibraryoptions.Input) async throws -> Operations.postLibraryVirtualfoldersLibraryoptions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLibraryVirtualfoldersLibraryoptions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Library/VirtualFolders/LibraryOptions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Library/VirtualFolders/Name`.
    /// - Remark: Generated from `#/paths//Library/VirtualFolders/Name/post(postLibraryVirtualfoldersName)`.
    internal func postLibraryVirtualfoldersName(_ input: Operations.postLibraryVirtualfoldersName.Input) async throws -> Operations.postLibraryVirtualfoldersName.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLibraryVirtualfoldersName.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Library/VirtualFolders/Name",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Library/VirtualFolders/Delete`.
    /// - Remark: Generated from `#/paths//Library/VirtualFolders/Delete/post(postLibraryVirtualfoldersDelete)`.
    internal func postLibraryVirtualfoldersDelete(_ input: Operations.postLibraryVirtualfoldersDelete.Input) async throws -> Operations.postLibraryVirtualfoldersDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLibraryVirtualfoldersDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Library/VirtualFolders/Delete",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Library/VirtualFolders/Paths`.
    /// - Remark: Generated from `#/paths//Library/VirtualFolders/Paths/post(postLibraryVirtualfoldersPaths)`.
    internal func postLibraryVirtualfoldersPaths(_ input: Operations.postLibraryVirtualfoldersPaths.Input) async throws -> Operations.postLibraryVirtualfoldersPaths.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLibraryVirtualfoldersPaths.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Library/VirtualFolders/Paths",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `DELETE /Library/VirtualFolders/Paths`.
    /// - Remark: Generated from `#/paths//Library/VirtualFolders/Paths/delete(deleteLibraryVirtualfoldersPaths)`.
    internal func deleteLibraryVirtualfoldersPaths(_ input: Operations.deleteLibraryVirtualfoldersPaths.Input) async throws -> Operations.deleteLibraryVirtualfoldersPaths.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteLibraryVirtualfoldersPaths.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Library/VirtualFolders/Paths",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a live tv program
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/Programs/{Id}`.
    /// - Remark: Generated from `#/paths//LiveTv/Programs/{Id}/get(getLivetvProgramsById)`.
    internal func getLivetvProgramsById(_ input: Operations.getLivetvProgramsById.Input) async throws -> Operations.getLivetvProgramsById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvProgramsById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Programs/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvProgramsById.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/TunerHosts/Types`.
    /// - Remark: Generated from `#/paths//LiveTv/TunerHosts/Types/get(getLivetvTunerhostsTypes)`.
    internal func getLivetvTunerhostsTypes(_ input: Operations.getLivetvTunerhostsTypes.Input) async throws -> Operations.getLivetvTunerhostsTypes.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvTunerhostsTypes.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/TunerHosts/Types",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvTunerhostsTypes.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.NameIdPair].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets the channel management list
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /LiveTv/Manage/Channels`.
    /// - Remark: Generated from `#/paths//LiveTv/Manage/Channels/get(getLivetvManageChannels)`.
    internal func getLivetvManageChannels(_ input: Operations.getLivetvManageChannels.Input) async throws -> Operations.getLivetvManageChannels.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvManageChannels.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Manage/Channels",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvManageChannels.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_ChannelManagementInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets live tv channel tag prefixes
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/ChannelTags/Prefixes`.
    /// - Remark: Generated from `#/paths//LiveTv/ChannelTags/Prefixes/get(getLivetvChanneltagsPrefixes)`.
    internal func getLivetvChanneltagsPrefixes(_ input: Operations.getLivetvChanneltagsPrefixes.Input) async throws -> Operations.getLivetvChanneltagsPrefixes.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvChanneltagsPrefixes.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/ChannelTags/Prefixes",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvChanneltagsPrefixes.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Api_period_TagItem].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets recording folders
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/Recordings/Folders`.
    /// - Remark: Generated from `#/paths//LiveTv/Recordings/Folders/get(getLivetvRecordingsFolders)`.
    internal func getLivetvRecordingsFolders(_ input: Operations.getLivetvRecordingsFolders.Input) async throws -> Operations.getLivetvRecordingsFolders.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvRecordingsFolders.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Recordings/Folders",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvRecordingsFolders.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.BaseItemDto].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/Tuners/Discvover`.
    /// - Remark: Generated from `#/paths//LiveTv/Tuners/Discvover/get(getLivetvTunersDiscvover)`.
    internal func getLivetvTunersDiscvover(_ input: Operations.getLivetvTunersDiscvover.Input) async throws -> Operations.getLivetvTunersDiscvover.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvTunersDiscvover.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Tuners/Discvover",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvTunersDiscvover.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.LiveTv_period_TunerHostInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/ListingProviders/Default`.
    /// - Remark: Generated from `#/paths//LiveTv/ListingProviders/Default/get(getLivetvListingprovidersDefault)`.
    internal func getLivetvListingprovidersDefault(_ input: Operations.getLivetvListingprovidersDefault.Input) async throws -> Operations.getLivetvListingprovidersDefault.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvListingprovidersDefault.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/ListingProviders/Default",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvListingprovidersDefault.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LiveTv_period_ListingsProviderInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deletes a listing provider
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /LiveTv/ListingProviders/Delete`.
    /// - Remark: Generated from `#/paths//LiveTv/ListingProviders/Delete/post(postLivetvListingprovidersDelete)`.
    internal func postLivetvListingprovidersDelete(_ input: Operations.postLivetvListingprovidersDelete.Input) async throws -> Operations.postLivetvListingprovidersDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLivetvListingprovidersDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/ListingProviders/Delete",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Id",
                    value: input.query.Id
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deletes a tuner host
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /LiveTv/TunerHosts/Delete`.
    /// - Remark: Generated from `#/paths//LiveTv/TunerHosts/Delete/post(postLivetvTunerhostsDelete)`.
    internal func postLivetvTunerhostsDelete(_ input: Operations.postLivetvTunerhostsDelete.Input) async throws -> Operations.postLivetvTunerhostsDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLivetvTunerhostsDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/TunerHosts/Delete",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Id",
                    value: input.query.Id
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets available lineups
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /LiveTv/ListingProviders/Lineups`.
    /// - Remark: Generated from `#/paths//LiveTv/ListingProviders/Lineups/get(getLivetvListingprovidersLineups)`.
    internal func getLivetvListingprovidersLineups(_ input: Operations.getLivetvListingprovidersLineups.Input) async throws -> Operations.getLivetvListingprovidersLineups.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvListingprovidersLineups.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/ListingProviders/Lineups",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Id",
                    value: input.query.Id
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Type",
                    value: input.query._Type
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Location",
                    value: input.query.Location
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Country",
                    value: input.query.Country
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvListingprovidersLineups.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.NameIdPair].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a live tv channel
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/Channels/{Id}`.
    /// - Remark: Generated from `#/paths//LiveTv/Channels/{Id}/get(getLivetvChannelsById)`.
    internal func getLivetvChannelsById(_ input: Operations.getLivetvChannelsById.Input) async throws -> Operations.getLivetvChannelsById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvChannelsById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Channels/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvChannelsById.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets available live tv epgs..
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/Programs/Recommended`.
    /// - Remark: Generated from `#/paths//LiveTv/Programs/Recommended/get(getLivetvProgramsRecommended)`.
    internal func getLivetvProgramsRecommended(_ input: Operations.getLivetvProgramsRecommended.Input) async throws -> Operations.getLivetvProgramsRecommended.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvProgramsRecommended.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Programs/Recommended",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsAiring",
                    value: input.query.IsAiring
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasAired",
                    value: input.query.HasAired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GenreIds",
                    value: input.query.GenreIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvProgramsRecommended.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets live tv recordings
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/Recordings/Series`.
    /// - Remark: Generated from `#/paths//LiveTv/Recordings/Series/get(getLivetvRecordingsSeries)`.
    internal func getLivetvRecordingsSeries(_ input: Operations.getLivetvRecordingsSeries.Input) async throws -> Operations.getLivetvRecordingsSeries.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvRecordingsSeries.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Recordings/Series",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvRecordingsSeries.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a live tv recording
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/Recordings/{Id}`.
    /// - Remark: Generated from `#/paths//LiveTv/Recordings/{Id}/get(getLivetvRecordingsById)`.
    internal func getLivetvRecordingsById(_ input: Operations.getLivetvRecordingsById.Input) async throws -> Operations.getLivetvRecordingsById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvRecordingsById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Recordings/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvRecordingsById.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deletes a live tv recording
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `DELETE /LiveTv/Recordings/{Id}`.
    /// - Remark: Generated from `#/paths//LiveTv/Recordings/{Id}/delete(deleteLivetvRecordingsById)`.
    internal func deleteLivetvRecordingsById(_ input: Operations.deleteLivetvRecordingsById.Input) async throws -> Operations.deleteLivetvRecordingsById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteLivetvRecordingsById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Recordings/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a live tv timer
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/Timers/{Id}`.
    /// - Remark: Generated from `#/paths//LiveTv/Timers/{Id}/get(getLivetvTimersById)`.
    internal func getLivetvTimersById(_ input: Operations.getLivetvTimersById.Input) async throws -> Operations.getLivetvTimersById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvTimersById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Timers/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvTimersById.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LiveTv_period_TimerInfoDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates a live tv timer
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /LiveTv/Timers/{Id}`.
    /// - Remark: Generated from `#/paths//LiveTv/Timers/{Id}/post(postLivetvTimersById)`.
    internal func postLivetvTimersById(_ input: Operations.postLivetvTimersById.Input) async throws -> Operations.postLivetvTimersById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLivetvTimersById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Timers/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Cancels a live tv timer
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `DELETE /LiveTv/Timers/{Id}`.
    /// - Remark: Generated from `#/paths//LiveTv/Timers/{Id}/delete(deleteLivetvTimersById)`.
    internal func deleteLivetvTimersById(_ input: Operations.deleteLivetvTimersById.Input) async throws -> Operations.deleteLivetvTimersById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteLivetvTimersById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Timers/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a live tv series timer
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/SeriesTimers/{Id}`.
    /// - Remark: Generated from `#/paths//LiveTv/SeriesTimers/{Id}/get(getLivetvSeriestimersById)`.
    internal func getLivetvSeriestimersById(_ input: Operations.getLivetvSeriestimersById.Input) async throws -> Operations.getLivetvSeriestimersById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvSeriestimersById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/SeriesTimers/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvSeriestimersById.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LiveTv_period_TimerInfoDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates a live tv series timer
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /LiveTv/SeriesTimers/{Id}`.
    /// - Remark: Generated from `#/paths//LiveTv/SeriesTimers/{Id}/post(postLivetvSeriestimersById)`.
    internal func postLivetvSeriestimersById(_ input: Operations.postLivetvSeriestimersById.Input) async throws -> Operations.postLivetvSeriestimersById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLivetvSeriestimersById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/SeriesTimers/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Cancels a live tv series timer
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `DELETE /LiveTv/SeriesTimers/{Id}`.
    /// - Remark: Generated from `#/paths//LiveTv/SeriesTimers/{Id}/delete(deleteLivetvSeriestimersById)`.
    internal func deleteLivetvSeriestimersById(_ input: Operations.deleteLivetvSeriestimersById.Input) async throws -> Operations.deleteLivetvSeriestimersById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteLivetvSeriestimersById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/SeriesTimers/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets default values for a new timer
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/Timers/Defaults`.
    /// - Remark: Generated from `#/paths//LiveTv/Timers/Defaults/get(getLivetvTimersDefaults)`.
    internal func getLivetvTimersDefaults(_ input: Operations.getLivetvTimersDefaults.Input) async throws -> Operations.getLivetvTimersDefaults.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvTimersDefaults.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Timers/Defaults",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProgramId",
                    value: input.query.ProgramId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvTimersDefaults.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LiveTv_period_SeriesTimerInfoDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets live tv recording groups
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/Recordings/Groups`.
    /// - Remark: Generated from `#/paths//LiveTv/Recordings/Groups/get(getLivetvRecordingsGroups)`.
    internal func getLivetvRecordingsGroups(_ input: Operations.getLivetvRecordingsGroups.Input) async throws -> Operations.getLivetvRecordingsGroups.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvRecordingsGroups.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Recordings/Groups",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvRecordingsGroups.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets listing provider
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /LiveTv/ListingProviders/Available`.
    /// - Remark: Generated from `#/paths//LiveTv/ListingProviders/Available/get(getLivetvListingprovidersAvailable)`.
    internal func getLivetvListingprovidersAvailable(_ input: Operations.getLivetvListingprovidersAvailable.Input) async throws -> Operations.getLivetvListingprovidersAvailable.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvListingprovidersAvailable.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/ListingProviders/Available",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvListingprovidersAvailable.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Api_period_ListingProviderTypeInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Finds movies and trailers similar to a given movie.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Movies/{Id}/Similar`.
    /// - Remark: Generated from `#/paths//Movies/{Id}/Similar/get(getMoviesByIdSimilar)`.
    internal func getMoviesByIdSimilar(_ input: Operations.getMoviesByIdSimilar.Input) async throws -> Operations.getMoviesByIdSimilar.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getMoviesByIdSimilar.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Movies/{}/Similar",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getMoviesByIdSimilar.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Creates an instant playlist based on a music genre
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /MusicGenres/{Name}/InstantMix`.
    /// - Remark: Generated from `#/paths//MusicGenres/{Name}/InstantMix/get(getMusicgenresByNameInstantmix)`.
    internal func getMusicgenresByNameInstantmix(_ input: Operations.getMusicgenresByNameInstantmix.Input) async throws -> Operations.getMusicgenresByNameInstantmix.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getMusicgenresByNameInstantmix.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/MusicGenres/{}/InstantMix",
                    parameters: [
                        input.path.Name
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getMusicgenresByNameInstantmix.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Sends a test notification
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Notifications/Services/Test`.
    /// - Remark: Generated from `#/paths//Notifications/Services/Test/post(postNotificationsServicesTest)`.
    internal func postNotificationsServicesTest(_ input: Operations.postNotificationsServicesTest.Input) async throws -> Operations.postNotificationsServicesTest.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postNotificationsServicesTest.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Notifications/Services/Test",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets default notification info
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Notifications/Services/Defaults`.
    /// - Remark: Generated from `#/paths//Notifications/Services/Defaults/get(getNotificationsServicesDefaults)`.
    internal func getNotificationsServicesDefaults(_ input: Operations.getNotificationsServicesDefaults.Input) async throws -> Operations.getNotificationsServicesDefaults.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getNotificationsServicesDefaults.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Notifications/Services/Defaults",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getNotificationsServicesDefaults.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserNotificationInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Installs a package
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Packages/Installed/{Name}`.
    /// - Remark: Generated from `#/paths//Packages/Installed/{Name}/post(postPackagesInstalledByName)`.
    internal func postPackagesInstalledByName(_ input: Operations.postPackagesInstalledByName.Input) async throws -> Operations.postPackagesInstalledByName.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postPackagesInstalledByName.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Packages/Installed/{}",
                    parameters: [
                        input.path.Name
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AssemblyGuid",
                    value: input.query.AssemblyGuid
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Version",
                    value: input.query.Version
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UpdateClass",
                    value: input.query.UpdateClass
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Cancels a package installation
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `DELETE /Packages/Installing/{Id}`.
    /// - Remark: Generated from `#/paths//Packages/Installing/{Id}/delete(deletePackagesInstallingById)`.
    internal func deletePackagesInstallingById(_ input: Operations.deletePackagesInstallingById.Input) async throws -> Operations.deletePackagesInstallingById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deletePackagesInstallingById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Packages/Installing/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets add to playlist info
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Playlists/{Id}/AddToPlaylistInfo`.
    /// - Remark: Generated from `#/paths//Playlists/{Id}/AddToPlaylistInfo/get(getPlaylistsByIdAddtoplaylistinfo)`.
    internal func getPlaylistsByIdAddtoplaylistinfo(_ input: Operations.getPlaylistsByIdAddtoplaylistinfo.Input) async throws -> Operations.getPlaylistsByIdAddtoplaylistinfo.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getPlaylistsByIdAddtoplaylistinfo.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Playlists/{}/AddToPlaylistInfo",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Ids",
                    value: input.query.Ids
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getPlaylistsByIdAddtoplaylistinfo.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets the original items of a playlist
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Playlists/{Id}/Items`.
    /// - Remark: Generated from `#/paths//Playlists/{Id}/Items/get(getPlaylistsByIdItems)`.
    internal func getPlaylistsByIdItems(_ input: Operations.getPlaylistsByIdItems.Input) async throws -> Operations.getPlaylistsByIdItems.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getPlaylistsByIdItems.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Playlists/{}/Items",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getPlaylistsByIdItems.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Adds items to a playlist
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Playlists/{Id}/Items`.
    /// - Remark: Generated from `#/paths//Playlists/{Id}/Items/post(postPlaylistsByIdItems)`.
    internal func postPlaylistsByIdItems(_ input: Operations.postPlaylistsByIdItems.Input) async throws -> Operations.postPlaylistsByIdItems.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postPlaylistsByIdItems.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Playlists/{}/Items",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Ids",
                    value: input.query.Ids
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postPlaylistsByIdItems.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Playlists_period_AddToPlaylistResult.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Removes items from a playlist
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `DELETE /Playlists/{Id}/Items`.
    /// - Remark: Generated from `#/paths//Playlists/{Id}/Items/delete(deletePlaylistsByIdItems)`.
    internal func deletePlaylistsByIdItems(_ input: Operations.deletePlaylistsByIdItems.Input) async throws -> Operations.deletePlaylistsByIdItems.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deletePlaylistsByIdItems.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Playlists/{}/Items",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EntryIds",
                    value: input.query.EntryIds
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Creates an instant playlist based on a given playlist
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Playlists/{Id}/InstantMix`.
    /// - Remark: Generated from `#/paths//Playlists/{Id}/InstantMix/get(getPlaylistsByIdInstantmix)`.
    internal func getPlaylistsByIdInstantmix(_ input: Operations.getPlaylistsByIdInstantmix.Input) async throws -> Operations.getPlaylistsByIdInstantmix.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getPlaylistsByIdInstantmix.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Playlists/{}/InstantMix",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getPlaylistsByIdInstantmix.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a plugin thumb image
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Plugins/{Id}/Thumb`.
    /// - Remark: Generated from `#/paths//Plugins/{Id}/Thumb/get(getPluginsByIdThumb)`.
    internal func getPluginsByIdThumb(_ input: Operations.getPluginsByIdThumb.Input) async throws -> Operations.getPluginsByIdThumb.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getPluginsByIdThumb.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Plugins/{}/Thumb",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a plugin's configuration
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /Plugins/{Id}/Configuration`.
    /// - Remark: Generated from `#/paths//Plugins/{Id}/Configuration/get(getPluginsByIdConfiguration)`.
    internal func getPluginsByIdConfiguration(_ input: Operations.getPluginsByIdConfiguration.Input) async throws -> Operations.getPluginsByIdConfiguration.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getPluginsByIdConfiguration.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Plugins/{}/Configuration",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates a plugin's configuration
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Plugins/{Id}/Configuration`.
    /// - Remark: Generated from `#/paths//Plugins/{Id}/Configuration/post(postPluginsByIdConfiguration)`.
    internal func postPluginsByIdConfiguration(_ input: Operations.postPluginsByIdConfiguration.Input) async throws -> Operations.postPluginsByIdConfiguration.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postPluginsByIdConfiguration.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Plugins/{}/Configuration",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .binary(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/octet-stream"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Uninstalls a plugin
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Plugins/{Id}/Delete`.
    /// - Remark: Generated from `#/paths//Plugins/{Id}/Delete/post(postPluginsByIdDelete)`.
    internal func postPluginsByIdDelete(_ input: Operations.postPluginsByIdDelete.Input) async throws -> Operations.postPluginsByIdDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postPluginsByIdDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Plugins/{}/Delete",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Starts a scheduled task
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /ScheduledTasks/Running/{Id}`.
    /// - Remark: Generated from `#/paths//ScheduledTasks/Running/{Id}/post(postScheduledtasksRunningById)`.
    internal func postScheduledtasksRunningById(_ input: Operations.postScheduledtasksRunningById.Input) async throws -> Operations.postScheduledtasksRunningById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postScheduledtasksRunningById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/ScheduledTasks/Running/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Stops a scheduled task
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `DELETE /ScheduledTasks/Running/{Id}`.
    /// - Remark: Generated from `#/paths//ScheduledTasks/Running/{Id}/delete(deleteScheduledtasksRunningById)`.
    internal func deleteScheduledtasksRunningById(_ input: Operations.deleteScheduledtasksRunningById.Input) async throws -> Operations.deleteScheduledtasksRunningById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteScheduledtasksRunningById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/ScheduledTasks/Running/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates the triggers for a scheduled task
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /ScheduledTasks/{Id}/Triggers`.
    /// - Remark: Generated from `#/paths//ScheduledTasks/{Id}/Triggers/post(postScheduledtasksByIdTriggers)`.
    internal func postScheduledtasksByIdTriggers(_ input: Operations.postScheduledtasksByIdTriggers.Input) async throws -> Operations.postScheduledtasksByIdTriggers.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postScheduledtasksByIdTriggers.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/ScheduledTasks/{}/Triggers",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Instructs a session to browse to an item or view
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sessions/{Id}/Viewing`.
    /// - Remark: Generated from `#/paths//Sessions/{Id}/Viewing/post(postSessionsByIdViewing)`.
    internal func postSessionsByIdViewing(_ input: Operations.postSessionsByIdViewing.Input) async throws -> Operations.postSessionsByIdViewing.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSessionsByIdViewing.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sessions/{}/Viewing",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ItemType",
                    value: input.query.ItemType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ItemId",
                    value: input.query.ItemId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ItemName",
                    value: input.query.ItemName
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Issues a command to a client to display a message to the user
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sessions/{Id}/Message`.
    /// - Remark: Generated from `#/paths//Sessions/{Id}/Message/post(postSessionsByIdMessage)`.
    internal func postSessionsByIdMessage(_ input: Operations.postSessionsByIdMessage.Input) async throws -> Operations.postSessionsByIdMessage.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSessionsByIdMessage.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sessions/{}/Message",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Text",
                    value: input.query.Text
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Header",
                    value: input.query.Header
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "TimeoutMs",
                    value: input.query.TimeoutMs
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Instructs a session to play an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sessions/{Id}/Playing`.
    /// - Remark: Generated from `#/paths//Sessions/{Id}/Playing/post(postSessionsByIdPlaying)`.
    internal func postSessionsByIdPlaying(_ input: Operations.postSessionsByIdPlaying.Input) async throws -> Operations.postSessionsByIdPlaying.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSessionsByIdPlaying.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sessions/{}/Playing",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ItemIds",
                    value: input.query.ItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartPositionTicks",
                    value: input.query.StartPositionTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PlayCommand",
                    value: input.query.PlayCommand
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Issues a system command to a client
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sessions/{Id}/Command`.
    /// - Remark: Generated from `#/paths//Sessions/{Id}/Command/post(postSessionsByIdCommand)`.
    internal func postSessionsByIdCommand(_ input: Operations.postSessionsByIdCommand.Input) async throws -> Operations.postSessionsByIdCommand.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSessionsByIdCommand.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sessions/{}/Command",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates capabilities for a device
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sessions/Capabilities/Full`.
    /// - Remark: Generated from `#/paths//Sessions/Capabilities/Full/post(postSessionsCapabilitiesFull)`.
    internal func postSessionsCapabilitiesFull(_ input: Operations.postSessionsCapabilitiesFull.Input) async throws -> Operations.postSessionsCapabilitiesFull.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSessionsCapabilitiesFull.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sessions/Capabilities/Full",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Id",
                    value: input.query.Id
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Reports playback progress within a session
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sessions/Playing/Progress`.
    /// - Remark: Generated from `#/paths//Sessions/Playing/Progress/post(postSessionsPlayingProgress)`.
    internal func postSessionsPlayingProgress(_ input: Operations.postSessionsPlayingProgress.Input) async throws -> Operations.postSessionsPlayingProgress.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSessionsPlayingProgress.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sessions/Playing/Progress",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Pings a playback session
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sessions/Playing/Ping`.
    /// - Remark: Generated from `#/paths//Sessions/Playing/Ping/post(postSessionsPlayingPing)`.
    internal func postSessionsPlayingPing(_ input: Operations.postSessionsPlayingPing.Input) async throws -> Operations.postSessionsPlayingPing.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSessionsPlayingPing.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sessions/Playing/Ping",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PlaySessionId",
                    value: input.query.PlaySessionId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Reports playback has stopped within a session
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sessions/Playing/Stopped`.
    /// - Remark: Generated from `#/paths//Sessions/Playing/Stopped/post(postSessionsPlayingStopped)`.
    internal func postSessionsPlayingStopped(_ input: Operations.postSessionsPlayingStopped.Input) async throws -> Operations.postSessionsPlayingStopped.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSessionsPlayingStopped.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sessions/Playing/Stopped",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets seasons for a tv series
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Shows/{Id}/Seasons`.
    /// - Remark: Generated from `#/paths//Shows/{Id}/Seasons/get(getShowsByIdSeasons)`.
    internal func getShowsByIdSeasons(_ input: Operations.getShowsByIdSeasons.Input) async throws -> Operations.getShowsByIdSeasons.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getShowsByIdSeasons.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Shows/{}/Seasons",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSpecialSeason",
                    value: input.query.IsSpecialSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getShowsByIdSeasons.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets episodes for a tv season
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Shows/{Id}/Episodes`.
    /// - Remark: Generated from `#/paths//Shows/{Id}/Episodes/get(getShowsByIdEpisodes)`.
    internal func getShowsByIdEpisodes(_ input: Operations.getShowsByIdEpisodes.Input) async throws -> Operations.getShowsByIdEpisodes.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getShowsByIdEpisodes.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Shows/{}/Episodes",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Season",
                    value: input.query.Season
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SeasonId",
                    value: input.query.SeasonId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartItemId",
                    value: input.query.StartItemId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Finds tv shows similar to a given one.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Shows/{Id}/Similar`.
    /// - Remark: Generated from `#/paths//Shows/{Id}/Similar/get(getShowsByIdSimilar)`.
    internal func getShowsByIdSimilar(_ input: Operations.getShowsByIdSimilar.Input) async throws -> Operations.getShowsByIdSimilar.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getShowsByIdSimilar.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Shows/{}/Similar",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getShowsByIdSimilar.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Creates an instant playlist based on a given song
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Songs/{Id}/InstantMix`.
    /// - Remark: Generated from `#/paths//Songs/{Id}/InstantMix/get(getSongsByIdInstantmix)`.
    internal func getSongsByIdInstantmix(_ input: Operations.getSongsByIdInstantmix.Input) async throws -> Operations.getSongsByIdInstantmix.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSongsByIdInstantmix.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Songs/{}/InstantMix",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSongsByIdInstantmix.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets sync status for an item.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sync/{ItemId}/Status`.
    /// - Remark: Generated from `#/paths//Sync/{ItemId}/Status/post(postSyncByItemidStatus)`.
    internal func postSyncByItemidStatus(_ input: Operations.postSyncByItemidStatus.Input) async throws -> Operations.postSyncByItemidStatus.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSyncByItemidStatus.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sync/{}/Status",
                    parameters: [
                        input.path.ItemId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a sync job.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Sync/Jobs/{Id}`.
    /// - Remark: Generated from `#/paths//Sync/Jobs/{Id}/get(getSyncJobsById)`.
    internal func getSyncJobsById(_ input: Operations.getSyncJobsById.Input) async throws -> Operations.getSyncJobsById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSyncJobsById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sync/Jobs/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSyncJobsById.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SyncJob.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates a sync job.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sync/Jobs/{Id}`.
    /// - Remark: Generated from `#/paths//Sync/Jobs/{Id}/post(postSyncJobsById)`.
    internal func postSyncJobsById(_ input: Operations.postSyncJobsById.Input) async throws -> Operations.postSyncJobsById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSyncJobsById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sync/Jobs/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Cancels a sync job.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `DELETE /Sync/Jobs/{Id}`.
    /// - Remark: Generated from `#/paths//Sync/Jobs/{Id}/delete(deleteSyncJobsById)`.
    internal func deleteSyncJobsById(_ input: Operations.deleteSyncJobsById.Input) async throws -> Operations.deleteSyncJobsById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteSyncJobsById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sync/Jobs/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Cancels items from a sync target
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sync/Items/Cancel`.
    /// - Remark: Generated from `#/paths//Sync/Items/Cancel/post(postSyncItemsCancel)`.
    internal func postSyncItemsCancel(_ input: Operations.postSyncItemsCancel.Input) async throws -> Operations.postSyncItemsCancel.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSyncItemsCancel.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sync/Items/Cancel",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ItemIds",
                    value: input.query.ItemIds
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Cancels items from a sync target
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `DELETE /Sync/{TargetId}/Items`.
    /// - Remark: Generated from `#/paths//Sync/{TargetId}/Items/delete(deleteSyncByTargetidItems)`.
    internal func deleteSyncByTargetidItems(_ input: Operations.deleteSyncByTargetidItems.Input) async throws -> Operations.deleteSyncByTargetidItems.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteSyncByTargetidItems.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sync/{}/Items",
                    parameters: [
                        input.path.TargetId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ItemIds",
                    value: input.query.ItemIds
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets ready to download sync items.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Sync/Items/Ready`.
    /// - Remark: Generated from `#/paths//Sync/Items/Ready/get(getSyncItemsReady)`.
    internal func getSyncItemsReady(_ input: Operations.getSyncItemsReady.Input) async throws -> Operations.getSyncItemsReady.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSyncItemsReady.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sync/Items/Ready",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "TargetId",
                    value: input.query.TargetId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSyncItemsReady.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.SyncedItem].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Cancels a sync job item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `DELETE /Sync/JobItems/{Id}`.
    /// - Remark: Generated from `#/paths//Sync/JobItems/{Id}/delete(deleteSyncJobitemsById)`.
    internal func deleteSyncJobitemsById(_ input: Operations.deleteSyncJobitemsById.Input) async throws -> Operations.deleteSyncJobitemsById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteSyncJobitemsById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sync/JobItems/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates application configuration
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /System/Configuration/Partial`.
    /// - Remark: Generated from `#/paths//System/Configuration/Partial/post(postSystemConfigurationPartial)`.
    internal func postSystemConfigurationPartial(_ input: Operations.postSystemConfigurationPartial.Input) async throws -> Operations.postSystemConfigurationPartial.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSystemConfigurationPartial.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/Configuration/Partial",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .binary(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/octet-stream"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a named configuration
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /System/Configuration/{Key}`.
    /// - Remark: Generated from `#/paths//System/Configuration/{Key}/get(getSystemConfigurationByKey)`.
    internal func getSystemConfigurationByKey(_ input: Operations.getSystemConfigurationByKey.Input) async throws -> Operations.getSystemConfigurationByKey.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSystemConfigurationByKey.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/Configuration/{}",
                    parameters: [
                        input.path.Key
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates named configuration
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /System/Configuration/{Key}`.
    /// - Remark: Generated from `#/paths//System/Configuration/{Key}/post(postSystemConfigurationByKey)`.
    internal func postSystemConfigurationByKey(_ input: Operations.postSystemConfigurationByKey.Input) async throws -> Operations.postSystemConfigurationByKey.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSystemConfigurationByKey.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/Configuration/{}",
                    parameters: [
                        input.path.Key
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .binary(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/octet-stream"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets release notes
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /System/ReleaseNotes/Versions`.
    /// - Remark: Generated from `#/paths//System/ReleaseNotes/Versions/get(getSystemReleasenotesVersions)`.
    internal func getSystemReleasenotesVersions(_ input: Operations.getSystemReleasenotesVersions.Input) async throws -> Operations.getSystemReleasenotesVersions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSystemReleasenotesVersions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/ReleaseNotes/Versions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSystemReleasenotesVersions.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.PackageVersionInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a list of available server log files
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /System/Logs/Query`.
    /// - Remark: Generated from `#/paths//System/Logs/Query/get(getSystemLogsQuery)`.
    internal func getSystemLogsQuery(_ input: Operations.getSystemLogsQuery.Input) async throws -> Operations.getSystemLogsQuery.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSystemLogsQuery.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/Logs/Query",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSystemLogsQuery.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_LogFile.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a log file
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /System/Logs/{Name}`.
    /// - Remark: Generated from `#/paths//System/Logs/{Name}/get(getSystemLogsByName)`.
    internal func getSystemLogsByName(_ input: Operations.getSystemLogsByName.Input) async throws -> Operations.getSystemLogsByName.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSystemLogsByName.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/Logs/{}",
                    parameters: [
                        input.path.Name
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Sanitize",
                    value: input.query.Sanitize
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets public information about the server
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /System/Info/Public`.
    /// - Remark: Generated from `#/paths//System/Info/Public/get(getSystemInfoPublic)`.
    internal func getSystemInfoPublic(_ input: Operations.getSystemInfoPublic.Input) async throws -> Operations.getSystemInfoPublic.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSystemInfoPublic.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/Info/Public",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSystemInfoPublic.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PublicSystemInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets activity log entries
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /System/ActivityLog/Entries`.
    /// - Remark: Generated from `#/paths//System/ActivityLog/Entries/get(getSystemActivitylogEntries)`.
    internal func getSystemActivitylogEntries(_ input: Operations.getSystemActivitylogEntries.Input) async throws -> Operations.getSystemActivitylogEntries.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSystemActivitylogEntries.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/ActivityLog/Entries",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDate",
                    value: input.query.MinDate
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSystemActivitylogEntries.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_ActivityLogEntry.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Finds movies and trailers similar to a given trailer.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Trailers/{Id}/Similar`.
    /// - Remark: Generated from `#/paths//Trailers/{Id}/Similar/get(getTrailersByIdSimilar)`.
    internal func getTrailersByIdSimilar(_ input: Operations.getTrailersByIdSimilar.Input) async throws -> Operations.getTrailersByIdSimilar.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getTrailersByIdSimilar.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Trailers/{}/Similar",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getTrailersByIdSimilar.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets items based on a query.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Users/{UserId}/Suggestions`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/Suggestions/get(getUsersByUseridSuggestions)`.
    internal func getUsersByUseridSuggestions(_ input: Operations.getUsersByUseridSuggestions.Input) async throws -> Operations.getUsersByUseridSuggestions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUsersByUseridSuggestions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Suggestions",
                    parameters: [
                        input.path.UserId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getUsersByUseridSuggestions.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deletes a user
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Users/{Id}/Delete`.
    /// - Remark: Generated from `#/paths//Users/{Id}/Delete/post(postUsersByIdDelete)`.
    internal func postUsersByIdDelete(_ input: Operations.postUsersByIdDelete.Input) async throws -> Operations.postUsersByIdDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByIdDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Delete",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Authenticates a user
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{Id}/Authenticate`.
    /// - Remark: Generated from `#/paths//Users/{Id}/Authenticate/post(postUsersByIdAuthenticate)`.
    internal func postUsersByIdAuthenticate(_ input: Operations.postUsersByIdAuthenticate.Input) async throws -> Operations.postUsersByIdAuthenticate.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByIdAuthenticate.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Authenticate",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postUsersByIdAuthenticate.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Authentication_period_AuthenticationResult.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates a user's password
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{Id}/Password`.
    /// - Remark: Generated from `#/paths//Users/{Id}/Password/post(postUsersByIdPassword)`.
    internal func postUsersByIdPassword(_ input: Operations.postUsersByIdPassword.Input) async throws -> Operations.postUsersByIdPassword.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByIdPassword.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Password",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Redeems a forgot password pin
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/ForgotPassword/Pin`.
    /// - Remark: Generated from `#/paths//Users/ForgotPassword/Pin/post(postUsersForgotpasswordPin)`.
    internal func postUsersForgotpasswordPin(_ input: Operations.postUsersForgotpasswordPin.Input) async throws -> Operations.postUsersForgotpasswordPin.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersForgotpasswordPin.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/ForgotPassword/Pin",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postUsersForgotpasswordPin.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PinRedeemResult.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates a user configuration
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{Id}/Configuration`.
    /// - Remark: Generated from `#/paths//Users/{Id}/Configuration/post(postUsersByIdConfiguration)`.
    internal func postUsersByIdConfiguration(_ input: Operations.postUsersByIdConfiguration.Input) async throws -> Operations.postUsersByIdConfiguration.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByIdConfiguration.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Configuration",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates a user policy
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Users/{Id}/Policy`.
    /// - Remark: Generated from `#/paths//Users/{Id}/Policy/post(postUsersByIdPolicy)`.
    internal func postUsersByIdPolicy(_ input: Operations.postUsersByIdPolicy.Input) async throws -> Operations.postUsersByIdPolicy.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByIdPolicy.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Policy",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets items based on a query.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Users/{UserId}/Items`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/Items/get(getUsersByUseridItems)`.
    internal func getUsersByUseridItems(_ input: Operations.getUsersByUseridItems.Input) async throws -> Operations.getUsersByUseridItems.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUsersByUseridItems.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Items",
                    parameters: [
                        input.path.UserId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getUsersByUseridItems.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Users/{UserId}/Views`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/Views/get(getUsersByUseridViews)`.
    internal func getUsersByUseridViews(_ input: Operations.getUsersByUseridViews.Input) async throws -> Operations.getUsersByUseridViews.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUsersByUseridViews.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Views",
                    parameters: [
                        input.path.UserId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IncludeExternalContent",
                    value: input.query.IncludeExternalContent
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getUsersByUseridViews.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Removes alternate video sources.
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `DELETE /Videos/{Id}/AlternateSources`.
    /// - Remark: Generated from `#/paths//Videos/{Id}/AlternateSources/delete(deleteVideosByIdAlternatesources)`.
    internal func deleteVideosByIdAlternatesources(_ input: Operations.deleteVideosByIdAlternatesources.Input) async throws -> Operations.deleteVideosByIdAlternatesources.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteVideosByIdAlternatesources.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/{}/AlternateSources",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets additional parts for a video.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Videos/{Id}/AdditionalParts`.
    /// - Remark: Generated from `#/paths//Videos/{Id}/AdditionalParts/get(getVideosByIdAdditionalparts)`.
    internal func getVideosByIdAdditionalparts(_ input: Operations.getVideosByIdAdditionalparts.Input) async throws -> Operations.getVideosByIdAdditionalparts.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getVideosByIdAdditionalparts.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/{}/AdditionalParts",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "UserId",
                    value: input.query.UserId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getVideosByIdAdditionalparts.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Videos/{Id}/index.bif`.
    /// - Remark: Generated from `#/paths//Videos/{Id}/index.bif/get(getVideosByIdIndexBif)`.
    internal func getVideosByIdIndexBif(_ input: Operations.getVideosByIdIndexBif.Input) async throws -> Operations.getVideosByIdIndexBif.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getVideosByIdIndexBif.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/{}/index.bif",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a video stream
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Videos/{Id}/stream.{Container}`.
    /// - Remark: Generated from `#/paths//Videos/{Id}/stream.{Container}/get(getVideosByIdStreamByContainer)`.
    internal func getVideosByIdStreamByContainer(_ input: Operations.getVideosByIdStreamByContainer.Input) async throws -> Operations.getVideosByIdStreamByContainer.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getVideosByIdStreamByContainer.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/{}/stream.{}",
                    parameters: [
                        input.path.Id,
                        input.path.Container
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceProfileId",
                    value: input.query.DeviceProfileId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioCodec",
                    value: input.query.AudioCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableAutoStreamCopy",
                    value: input.query.EnableAutoStreamCopy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioSampleRate",
                    value: input.query.AudioSampleRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioBitRate",
                    value: input.query.AudioBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioChannels",
                    value: input.query.AudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxAudioChannels",
                    value: input.query.MaxAudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Static",
                    value: input.query.Static
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartTimeTicks",
                    value: input.query.StartTimeTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoBitRate",
                    value: input.query.VideoBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleStreamIndex",
                    value: input.query.SubtitleStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleMethod",
                    value: input.query.SubtitleMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxVideoBitDepth",
                    value: input.query.MaxVideoBitDepth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoCodec",
                    value: input.query.VideoCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioStreamIndex",
                    value: input.query.AudioStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoStreamIndex",
                    value: input.query.VideoStreamIndex
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a video stream
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Videos/{Id}/stream.{Container}`.
    /// - Remark: Generated from `#/paths//Videos/{Id}/stream.{Container}/head(headVideosByIdStreamByContainer)`.
    internal func headVideosByIdStreamByContainer(_ input: Operations.headVideosByIdStreamByContainer.Input) async throws -> Operations.headVideosByIdStreamByContainer.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headVideosByIdStreamByContainer.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/{}/stream.{}",
                    parameters: [
                        input.path.Id,
                        input.path.Container
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceProfileId",
                    value: input.query.DeviceProfileId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioCodec",
                    value: input.query.AudioCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableAutoStreamCopy",
                    value: input.query.EnableAutoStreamCopy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioSampleRate",
                    value: input.query.AudioSampleRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioBitRate",
                    value: input.query.AudioBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioChannels",
                    value: input.query.AudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxAudioChannels",
                    value: input.query.MaxAudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Static",
                    value: input.query.Static
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartTimeTicks",
                    value: input.query.StartTimeTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoBitRate",
                    value: input.query.VideoBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleStreamIndex",
                    value: input.query.SubtitleStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleMethod",
                    value: input.query.SubtitleMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxVideoBitDepth",
                    value: input.query.MaxVideoBitDepth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoCodec",
                    value: input.query.VideoCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioStreamIndex",
                    value: input.query.AudioStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoStreamIndex",
                    value: input.query.VideoStreamIndex
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a video stream
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Videos/{Id}/stream`.
    /// - Remark: Generated from `#/paths//Videos/{Id}/stream/get(getVideosByIdStream)`.
    internal func getVideosByIdStream(_ input: Operations.getVideosByIdStream.Input) async throws -> Operations.getVideosByIdStream.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getVideosByIdStream.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/{}/stream",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceProfileId",
                    value: input.query.DeviceProfileId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Container",
                    value: input.query.Container
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioCodec",
                    value: input.query.AudioCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableAutoStreamCopy",
                    value: input.query.EnableAutoStreamCopy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioSampleRate",
                    value: input.query.AudioSampleRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioBitRate",
                    value: input.query.AudioBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioChannels",
                    value: input.query.AudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxAudioChannels",
                    value: input.query.MaxAudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Static",
                    value: input.query.Static
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartTimeTicks",
                    value: input.query.StartTimeTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoBitRate",
                    value: input.query.VideoBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleStreamIndex",
                    value: input.query.SubtitleStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleMethod",
                    value: input.query.SubtitleMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxVideoBitDepth",
                    value: input.query.MaxVideoBitDepth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoCodec",
                    value: input.query.VideoCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioStreamIndex",
                    value: input.query.AudioStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoStreamIndex",
                    value: input.query.VideoStreamIndex
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a video stream
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Videos/{Id}/stream`.
    /// - Remark: Generated from `#/paths//Videos/{Id}/stream/head(headVideosByIdStream)`.
    internal func headVideosByIdStream(_ input: Operations.headVideosByIdStream.Input) async throws -> Operations.headVideosByIdStream.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headVideosByIdStream.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/{}/stream",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceProfileId",
                    value: input.query.DeviceProfileId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Container",
                    value: input.query.Container
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioCodec",
                    value: input.query.AudioCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableAutoStreamCopy",
                    value: input.query.EnableAutoStreamCopy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioSampleRate",
                    value: input.query.AudioSampleRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioBitRate",
                    value: input.query.AudioBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioChannels",
                    value: input.query.AudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxAudioChannels",
                    value: input.query.MaxAudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Static",
                    value: input.query.Static
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartTimeTicks",
                    value: input.query.StartTimeTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoBitRate",
                    value: input.query.VideoBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleStreamIndex",
                    value: input.query.SubtitleStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleMethod",
                    value: input.query.SubtitleMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxVideoBitDepth",
                    value: input.query.MaxVideoBitDepth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoCodec",
                    value: input.query.VideoCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioStreamIndex",
                    value: input.query.AudioStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoStreamIndex",
                    value: input.query.VideoStreamIndex
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a video stream
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Videos/{Id}/{StreamFileName}`.
    /// - Remark: Generated from `#/paths//Videos/{Id}/{StreamFileName}/get(getVideosByIdByStreamfilename)`.
    internal func getVideosByIdByStreamfilename(_ input: Operations.getVideosByIdByStreamfilename.Input) async throws -> Operations.getVideosByIdByStreamfilename.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getVideosByIdByStreamfilename.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/{}/{}",
                    parameters: [
                        input.path.Id,
                        input.path.StreamFileName
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceProfileId",
                    value: input.query.DeviceProfileId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Container",
                    value: input.query.Container
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioCodec",
                    value: input.query.AudioCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableAutoStreamCopy",
                    value: input.query.EnableAutoStreamCopy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioSampleRate",
                    value: input.query.AudioSampleRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioBitRate",
                    value: input.query.AudioBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioChannels",
                    value: input.query.AudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxAudioChannels",
                    value: input.query.MaxAudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Static",
                    value: input.query.Static
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartTimeTicks",
                    value: input.query.StartTimeTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoBitRate",
                    value: input.query.VideoBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleStreamIndex",
                    value: input.query.SubtitleStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleMethod",
                    value: input.query.SubtitleMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxVideoBitDepth",
                    value: input.query.MaxVideoBitDepth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoCodec",
                    value: input.query.VideoCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioStreamIndex",
                    value: input.query.AudioStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoStreamIndex",
                    value: input.query.VideoStreamIndex
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a video stream
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Videos/{Id}/{StreamFileName}`.
    /// - Remark: Generated from `#/paths//Videos/{Id}/{StreamFileName}/head(headVideosByIdByStreamfilename)`.
    internal func headVideosByIdByStreamfilename(_ input: Operations.headVideosByIdByStreamfilename.Input) async throws -> Operations.headVideosByIdByStreamfilename.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headVideosByIdByStreamfilename.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/{}/{}",
                    parameters: [
                        input.path.Id,
                        input.path.StreamFileName
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceProfileId",
                    value: input.query.DeviceProfileId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Container",
                    value: input.query.Container
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioCodec",
                    value: input.query.AudioCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableAutoStreamCopy",
                    value: input.query.EnableAutoStreamCopy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioSampleRate",
                    value: input.query.AudioSampleRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioBitRate",
                    value: input.query.AudioBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioChannels",
                    value: input.query.AudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxAudioChannels",
                    value: input.query.MaxAudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Static",
                    value: input.query.Static
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartTimeTicks",
                    value: input.query.StartTimeTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoBitRate",
                    value: input.query.VideoBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleStreamIndex",
                    value: input.query.SubtitleStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleMethod",
                    value: input.query.SubtitleMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxVideoBitDepth",
                    value: input.query.MaxVideoBitDepth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoCodec",
                    value: input.query.VideoCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioStreamIndex",
                    value: input.query.AudioStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoStreamIndex",
                    value: input.query.VideoStreamIndex
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a video stream using HTTP live streaming.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Videos/{Id}/master.m3u8`.
    /// - Remark: Generated from `#/paths//Videos/{Id}/master.m3u8/get(getVideosByIdMasterM3u8)`.
    internal func getVideosByIdMasterM3u8(_ input: Operations.getVideosByIdMasterM3u8.Input) async throws -> Operations.getVideosByIdMasterM3u8.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getVideosByIdMasterM3u8.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/{}/master.m3u8",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceProfileId",
                    value: input.query.DeviceProfileId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Container",
                    value: input.query.Container
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioCodec",
                    value: input.query.AudioCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableAutoStreamCopy",
                    value: input.query.EnableAutoStreamCopy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioSampleRate",
                    value: input.query.AudioSampleRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioBitRate",
                    value: input.query.AudioBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioChannels",
                    value: input.query.AudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxAudioChannels",
                    value: input.query.MaxAudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Static",
                    value: input.query.Static
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartTimeTicks",
                    value: input.query.StartTimeTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoBitRate",
                    value: input.query.VideoBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleStreamIndex",
                    value: input.query.SubtitleStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleMethod",
                    value: input.query.SubtitleMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxVideoBitDepth",
                    value: input.query.MaxVideoBitDepth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoCodec",
                    value: input.query.VideoCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioStreamIndex",
                    value: input.query.AudioStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoStreamIndex",
                    value: input.query.VideoStreamIndex
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a video stream using HTTP live streaming.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Videos/{Id}/master.m3u8`.
    /// - Remark: Generated from `#/paths//Videos/{Id}/master.m3u8/head(headVideosByIdMasterM3u8)`.
    internal func headVideosByIdMasterM3u8(_ input: Operations.headVideosByIdMasterM3u8.Input) async throws -> Operations.headVideosByIdMasterM3u8.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headVideosByIdMasterM3u8.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/{}/master.m3u8",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceProfileId",
                    value: input.query.DeviceProfileId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Container",
                    value: input.query.Container
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioCodec",
                    value: input.query.AudioCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableAutoStreamCopy",
                    value: input.query.EnableAutoStreamCopy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioSampleRate",
                    value: input.query.AudioSampleRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioBitRate",
                    value: input.query.AudioBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioChannels",
                    value: input.query.AudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxAudioChannels",
                    value: input.query.MaxAudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Static",
                    value: input.query.Static
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartTimeTicks",
                    value: input.query.StartTimeTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoBitRate",
                    value: input.query.VideoBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleStreamIndex",
                    value: input.query.SubtitleStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleMethod",
                    value: input.query.SubtitleMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxVideoBitDepth",
                    value: input.query.MaxVideoBitDepth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoCodec",
                    value: input.query.VideoCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioStreamIndex",
                    value: input.query.AudioStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoStreamIndex",
                    value: input.query.VideoStreamIndex
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Videos/{Id}/live.m3u8`.
    /// - Remark: Generated from `#/paths//Videos/{Id}/live.m3u8/get(getVideosByIdLiveM3u8)`.
    internal func getVideosByIdLiveM3u8(_ input: Operations.getVideosByIdLiveM3u8.Input) async throws -> Operations.getVideosByIdLiveM3u8.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getVideosByIdLiveM3u8.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/{}/live.m3u8",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceProfileId",
                    value: input.query.DeviceProfileId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Container",
                    value: input.query.Container
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioCodec",
                    value: input.query.AudioCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableAutoStreamCopy",
                    value: input.query.EnableAutoStreamCopy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioSampleRate",
                    value: input.query.AudioSampleRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioBitRate",
                    value: input.query.AudioBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioChannels",
                    value: input.query.AudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxAudioChannels",
                    value: input.query.MaxAudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Static",
                    value: input.query.Static
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartTimeTicks",
                    value: input.query.StartTimeTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoBitRate",
                    value: input.query.VideoBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleStreamIndex",
                    value: input.query.SubtitleStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleMethod",
                    value: input.query.SubtitleMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxVideoBitDepth",
                    value: input.query.MaxVideoBitDepth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoCodec",
                    value: input.query.VideoCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioStreamIndex",
                    value: input.query.AudioStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoStreamIndex",
                    value: input.query.VideoStreamIndex
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a video stream using HTTP live streaming.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Videos/{Id}/main.m3u8`.
    /// - Remark: Generated from `#/paths//Videos/{Id}/main.m3u8/get(getVideosByIdMainM3u8)`.
    internal func getVideosByIdMainM3u8(_ input: Operations.getVideosByIdMainM3u8.Input) async throws -> Operations.getVideosByIdMainM3u8.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getVideosByIdMainM3u8.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/{}/main.m3u8",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceProfileId",
                    value: input.query.DeviceProfileId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Container",
                    value: input.query.Container
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioCodec",
                    value: input.query.AudioCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableAutoStreamCopy",
                    value: input.query.EnableAutoStreamCopy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioSampleRate",
                    value: input.query.AudioSampleRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioBitRate",
                    value: input.query.AudioBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioChannels",
                    value: input.query.AudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxAudioChannels",
                    value: input.query.MaxAudioChannels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Static",
                    value: input.query.Static
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartTimeTicks",
                    value: input.query.StartTimeTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoBitRate",
                    value: input.query.VideoBitRate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleStreamIndex",
                    value: input.query.SubtitleStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleMethod",
                    value: input.query.SubtitleMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxVideoBitDepth",
                    value: input.query.MaxVideoBitDepth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoCodec",
                    value: input.query.VideoCodec
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioStreamIndex",
                    value: input.query.AudioStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VideoStreamIndex",
                    value: input.query.VideoStreamIndex
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets an HLS subtitle playlist.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Videos/{Id}/subtitles.m3u8`.
    /// - Remark: Generated from `#/paths//Videos/{Id}/subtitles.m3u8/get(getVideosByIdSubtitlesM3u8)`.
    internal func getVideosByIdSubtitlesM3u8(_ input: Operations.getVideosByIdSubtitlesM3u8.Input) async throws -> Operations.getVideosByIdSubtitlesM3u8.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getVideosByIdSubtitlesM3u8.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/{}/subtitles.m3u8",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleSegmentLength",
                    value: input.query.SubtitleSegmentLength
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ManifestSubtitles",
                    value: input.query.ManifestSubtitles
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets an HLS subtitle playlist.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Videos/{Id}/live_subtitles.m3u8`.
    /// - Remark: Generated from `#/paths//Videos/{Id}/live_subtitles.m3u8/get(getVideosByIdLiveSubtitlesM3u8)`.
    internal func getVideosByIdLiveSubtitlesM3u8(_ input: Operations.getVideosByIdLiveSubtitlesM3u8.Input) async throws -> Operations.getVideosByIdLiveSubtitlesM3u8.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getVideosByIdLiveSubtitlesM3u8.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/{}/live_subtitles.m3u8",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleSegmentLength",
                    value: input.query.SubtitleSegmentLength
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ManifestSubtitles",
                    value: input.query.ManifestSubtitles
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Videos/ActiveEncodings/Delete`.
    /// - Remark: Generated from `#/paths//Videos/ActiveEncodings/Delete/post(postVideosActiveencodingsDelete)`.
    internal func postVideosActiveencodingsDelete(_ input: Operations.postVideosActiveencodingsDelete.Input) async throws -> Operations.postVideosActiveencodingsDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postVideosActiveencodingsDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/ActiveEncodings/Delete",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DeviceId",
                    value: input.query.DeviceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PlaySessionId",
                    value: input.query.PlaySessionId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Artists/{Name}/Images/{Type}`.
    /// - Remark: Generated from `#/paths//Artists/{Name}/Images/{Type}/get(getArtistsByNameImagesByType)`.
    internal func getArtistsByNameImagesByType(_ input: Operations.getArtistsByNameImagesByType.Input) async throws -> Operations.getArtistsByNameImagesByType.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getArtistsByNameImagesByType.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Artists/{}/Images/{}",
                    parameters: [
                        input.path.Name,
                        input.path._Type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Index",
                    value: input.query.Index
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Artists/{Name}/Images/{Type}`.
    /// - Remark: Generated from `#/paths//Artists/{Name}/Images/{Type}/head(headArtistsByNameImagesByType)`.
    internal func headArtistsByNameImagesByType(_ input: Operations.headArtistsByNameImagesByType.Input) async throws -> Operations.headArtistsByNameImagesByType.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headArtistsByNameImagesByType.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Artists/{}/Images/{}",
                    parameters: [
                        input.path.Name,
                        input.path._Type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Index",
                    value: input.query.Index
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Auth/Keys/{Key}/Delete`.
    /// - Remark: Generated from `#/paths//Auth/Keys/{Key}/Delete/post(postAuthKeysByKeyDelete)`.
    internal func postAuthKeysByKeyDelete(_ input: Operations.postAuthKeysByKeyDelete.Input) async throws -> Operations.postAuthKeysByKeyDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postAuthKeysByKeyDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Auth/Keys/{}/Delete",
                    parameters: [
                        input.path.Key
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Removes items from a collection
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Collections/{Id}/Items/Delete`.
    /// - Remark: Generated from `#/paths//Collections/{Id}/Items/Delete/post(postCollectionsByIdItemsDelete)`.
    internal func postCollectionsByIdItemsDelete(_ input: Operations.postCollectionsByIdItemsDelete.Input) async throws -> Operations.postCollectionsByIdItemsDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postCollectionsByIdItemsDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Collections/{}/Items/Delete",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Ids",
                    value: input.query.Ids
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets dlna content directory xml
    ///
    /// No authentication required
    ///
    /// - Remark: HTTP `GET /Dlna/{UuId}/contentdirectory/contentdirectory.xml`.
    /// - Remark: Generated from `#/paths//Dlna/{UuId}/contentdirectory/contentdirectory.xml/get(getDlnaByUuidContentdirectoryContentdirectoryXml)`.
    internal func getDlnaByUuidContentdirectoryContentdirectoryXml(_ input: Operations.getDlnaByUuidContentdirectoryContentdirectoryXml.Input) async throws -> Operations.getDlnaByUuidContentdirectoryContentdirectoryXml.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getDlnaByUuidContentdirectoryContentdirectoryXml.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Dlna/{}/contentdirectory/contentdirectory.xml",
                    parameters: [
                        input.path.UuId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets dlna content directory xml
    ///
    /// No authentication required
    ///
    /// - Remark: HTTP `HEAD /Dlna/{UuId}/contentdirectory/contentdirectory.xml`.
    /// - Remark: Generated from `#/paths//Dlna/{UuId}/contentdirectory/contentdirectory.xml/head(headDlnaByUuidContentdirectoryContentdirectoryXml)`.
    internal func headDlnaByUuidContentdirectoryContentdirectoryXml(_ input: Operations.headDlnaByUuidContentdirectoryContentdirectoryXml.Input) async throws -> Operations.headDlnaByUuidContentdirectoryContentdirectoryXml.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headDlnaByUuidContentdirectoryContentdirectoryXml.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Dlna/{}/contentdirectory/contentdirectory.xml",
                    parameters: [
                        input.path.UuId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets dlna content directory xml
    ///
    /// No authentication required
    ///
    /// - Remark: HTTP `GET /Dlna/{UuId}/contentdirectory/contentdirectory`.
    /// - Remark: Generated from `#/paths//Dlna/{UuId}/contentdirectory/contentdirectory/get(getDlnaByUuidContentdirectoryContentdirectory)`.
    internal func getDlnaByUuidContentdirectoryContentdirectory(_ input: Operations.getDlnaByUuidContentdirectoryContentdirectory.Input) async throws -> Operations.getDlnaByUuidContentdirectoryContentdirectory.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getDlnaByUuidContentdirectoryContentdirectory.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Dlna/{}/contentdirectory/contentdirectory",
                    parameters: [
                        input.path.UuId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets dlna content directory xml
    ///
    /// No authentication required
    ///
    /// - Remark: HTTP `HEAD /Dlna/{UuId}/contentdirectory/contentdirectory`.
    /// - Remark: Generated from `#/paths//Dlna/{UuId}/contentdirectory/contentdirectory/head(headDlnaByUuidContentdirectoryContentdirectory)`.
    internal func headDlnaByUuidContentdirectoryContentdirectory(_ input: Operations.headDlnaByUuidContentdirectoryContentdirectory.Input) async throws -> Operations.headDlnaByUuidContentdirectoryContentdirectory.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headDlnaByUuidContentdirectoryContentdirectory.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Dlna/{}/contentdirectory/contentdirectory",
                    parameters: [
                        input.path.UuId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets dlna connection manager xml
    ///
    /// No authentication required
    ///
    /// - Remark: HTTP `GET /Dlna/{UuId}/connectionmanager/connectionmanager.xml`.
    /// - Remark: Generated from `#/paths//Dlna/{UuId}/connectionmanager/connectionmanager.xml/get(getDlnaByUuidConnectionmanagerConnectionmanagerXml)`.
    internal func getDlnaByUuidConnectionmanagerConnectionmanagerXml(_ input: Operations.getDlnaByUuidConnectionmanagerConnectionmanagerXml.Input) async throws -> Operations.getDlnaByUuidConnectionmanagerConnectionmanagerXml.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getDlnaByUuidConnectionmanagerConnectionmanagerXml.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Dlna/{}/connectionmanager/connectionmanager.xml",
                    parameters: [
                        input.path.UuId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets dlna connection manager xml
    ///
    /// No authentication required
    ///
    /// - Remark: HTTP `HEAD /Dlna/{UuId}/connectionmanager/connectionmanager.xml`.
    /// - Remark: Generated from `#/paths//Dlna/{UuId}/connectionmanager/connectionmanager.xml/head(headDlnaByUuidConnectionmanagerConnectionmanagerXml)`.
    internal func headDlnaByUuidConnectionmanagerConnectionmanagerXml(_ input: Operations.headDlnaByUuidConnectionmanagerConnectionmanagerXml.Input) async throws -> Operations.headDlnaByUuidConnectionmanagerConnectionmanagerXml.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headDlnaByUuidConnectionmanagerConnectionmanagerXml.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Dlna/{}/connectionmanager/connectionmanager.xml",
                    parameters: [
                        input.path.UuId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets dlna connection manager xml
    ///
    /// No authentication required
    ///
    /// - Remark: HTTP `GET /Dlna/{UuId}/connectionmanager/connectionmanager`.
    /// - Remark: Generated from `#/paths//Dlna/{UuId}/connectionmanager/connectionmanager/get(getDlnaByUuidConnectionmanagerConnectionmanager)`.
    internal func getDlnaByUuidConnectionmanagerConnectionmanager(_ input: Operations.getDlnaByUuidConnectionmanagerConnectionmanager.Input) async throws -> Operations.getDlnaByUuidConnectionmanagerConnectionmanager.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getDlnaByUuidConnectionmanagerConnectionmanager.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Dlna/{}/connectionmanager/connectionmanager",
                    parameters: [
                        input.path.UuId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets dlna connection manager xml
    ///
    /// No authentication required
    ///
    /// - Remark: HTTP `HEAD /Dlna/{UuId}/connectionmanager/connectionmanager`.
    /// - Remark: Generated from `#/paths//Dlna/{UuId}/connectionmanager/connectionmanager/head(headDlnaByUuidConnectionmanagerConnectionmanager)`.
    internal func headDlnaByUuidConnectionmanagerConnectionmanager(_ input: Operations.headDlnaByUuidConnectionmanagerConnectionmanager.Input) async throws -> Operations.headDlnaByUuidConnectionmanagerConnectionmanager.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headDlnaByUuidConnectionmanagerConnectionmanager.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Dlna/{}/connectionmanager/connectionmanager",
                    parameters: [
                        input.path.UuId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Processes a control request
    ///
    /// No authentication required
    ///
    /// - Remark: HTTP `POST /Dlna/{UuId}/contentdirectory/control`.
    /// - Remark: Generated from `#/paths//Dlna/{UuId}/contentdirectory/control/post(postDlnaByUuidContentdirectoryControl)`.
    internal func postDlnaByUuidContentdirectoryControl(_ input: Operations.postDlnaByUuidContentdirectoryControl.Input) async throws -> Operations.postDlnaByUuidContentdirectoryControl.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postDlnaByUuidContentdirectoryControl.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Dlna/{}/contentdirectory/control",
                    parameters: [
                        input.path.UuId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .binary(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/octet-stream"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Processes a control request
    ///
    /// No authentication required
    ///
    /// - Remark: HTTP `POST /Dlna/{UuId}/connectionmanager/control`.
    /// - Remark: Generated from `#/paths//Dlna/{UuId}/connectionmanager/control/post(postDlnaByUuidConnectionmanagerControl)`.
    internal func postDlnaByUuidConnectionmanagerControl(_ input: Operations.postDlnaByUuidConnectionmanagerControl.Input) async throws -> Operations.postDlnaByUuidConnectionmanagerControl.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postDlnaByUuidConnectionmanagerControl.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Dlna/{}/connectionmanager/control",
                    parameters: [
                        input.path.UuId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .binary(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/octet-stream"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a server icon
    ///
    /// No authentication required
    ///
    /// - Remark: HTTP `GET /Dlna/{UuId}/icons/{Filename}`.
    /// - Remark: Generated from `#/paths//Dlna/{UuId}/icons/{Filename}/get(getDlnaByUuidIconsByFilename)`.
    internal func getDlnaByUuidIconsByFilename(_ input: Operations.getDlnaByUuidIconsByFilename.Input) async throws -> Operations.getDlnaByUuidIconsByFilename.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getDlnaByUuidIconsByFilename.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Dlna/{}/icons/{}",
                    parameters: [
                        input.path.UuId,
                        input.path.Filename
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /GameGenres/{Name}/Images/{Type}`.
    /// - Remark: Generated from `#/paths//GameGenres/{Name}/Images/{Type}/get(getGamegenresByNameImagesByType)`.
    internal func getGamegenresByNameImagesByType(_ input: Operations.getGamegenresByNameImagesByType.Input) async throws -> Operations.getGamegenresByNameImagesByType.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getGamegenresByNameImagesByType.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/GameGenres/{}/Images/{}",
                    parameters: [
                        input.path.Name,
                        input.path._Type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Index",
                    value: input.query.Index
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /GameGenres/{Name}/Images/{Type}`.
    /// - Remark: Generated from `#/paths//GameGenres/{Name}/Images/{Type}/head(headGamegenresByNameImagesByType)`.
    internal func headGamegenresByNameImagesByType(_ input: Operations.headGamegenresByNameImagesByType.Input) async throws -> Operations.headGamegenresByNameImagesByType.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headGamegenresByNameImagesByType.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/GameGenres/{}/Images/{}",
                    parameters: [
                        input.path.Name,
                        input.path._Type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Index",
                    value: input.query.Index
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Genres/{Name}/Images/{Type}`.
    /// - Remark: Generated from `#/paths//Genres/{Name}/Images/{Type}/get(getGenresByNameImagesByType)`.
    internal func getGenresByNameImagesByType(_ input: Operations.getGenresByNameImagesByType.Input) async throws -> Operations.getGenresByNameImagesByType.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getGenresByNameImagesByType.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Genres/{}/Images/{}",
                    parameters: [
                        input.path.Name,
                        input.path._Type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Index",
                    value: input.query.Index
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Genres/{Name}/Images/{Type}`.
    /// - Remark: Generated from `#/paths//Genres/{Name}/Images/{Type}/head(headGenresByNameImagesByType)`.
    internal func headGenresByNameImagesByType(_ input: Operations.headGenresByNameImagesByType.Input) async throws -> Operations.headGenresByNameImagesByType.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headGenresByNameImagesByType.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Genres/{}/Images/{}",
                    parameters: [
                        input.path.Name,
                        input.path._Type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Index",
                    value: input.query.Index
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Applies search criteria to an item and refreshes metadata
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Items/RemoteSearch/Apply/{Id}`.
    /// - Remark: Generated from `#/paths//Items/RemoteSearch/Apply/{Id}/post(postItemsRemotesearchApplyById)`.
    internal func postItemsRemotesearchApplyById(_ input: Operations.postItemsRemotesearchApplyById.Input) async throws -> Operations.postItemsRemotesearchApplyById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsRemotesearchApplyById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/RemoteSearch/Apply/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ReplaceAllImages",
                    value: input.query.ReplaceAllImages
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Adds new tags to an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Items/{Id}/Tags/Add`.
    /// - Remark: Generated from `#/paths//Items/{Id}/Tags/Add/post(postItemsByIdTagsAdd)`.
    internal func postItemsByIdTagsAdd(_ input: Operations.postItemsByIdTagsAdd.Input) async throws -> Operations.postItemsByIdTagsAdd.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsByIdTagsAdd.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/Tags/Add",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Removes tags from an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Items/{Id}/Tags/Delete`.
    /// - Remark: Generated from `#/paths//Items/{Id}/Tags/Delete/post(postItemsByIdTagsDelete)`.
    internal func postItemsByIdTagsDelete(_ input: Operations.postItemsByIdTagsDelete.Input) async throws -> Operations.postItemsByIdTagsDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsByIdTagsDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/Tags/Delete",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deletes an external subtitle file
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `DELETE /Items/{Id}/Subtitles/{Index}`.
    /// - Remark: Generated from `#/paths//Items/{Id}/Subtitles/{Index}/delete(deleteItemsByIdSubtitlesByIndex)`.
    internal func deleteItemsByIdSubtitlesByIndex(_ input: Operations.deleteItemsByIdSubtitlesByIndex.Input) async throws -> Operations.deleteItemsByIdSubtitlesByIndex.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteItemsByIdSubtitlesByIndex.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/Subtitles/{}",
                    parameters: [
                        input.path.Id,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MediaSourceId",
                    value: input.query.MediaSourceId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Items/{Id}/Images/{Type}`.
    /// - Remark: Generated from `#/paths//Items/{Id}/Images/{Type}/get(getItemsByIdImagesByType)`.
    internal func getItemsByIdImagesByType(_ input: Operations.getItemsByIdImagesByType.Input) async throws -> Operations.getItemsByIdImagesByType.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsByIdImagesByType.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/Images/{}",
                    parameters: [
                        input.path.Id,
                        input.path._Type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Index",
                    value: input.query.Index
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Uploads an image for an item, must be base64 encoded.
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Items/{Id}/Images/{Type}`.
    /// - Remark: Generated from `#/paths//Items/{Id}/Images/{Type}/post(postItemsByIdImagesByType)`.
    internal func postItemsByIdImagesByType(_ input: Operations.postItemsByIdImagesByType.Input) async throws -> Operations.postItemsByIdImagesByType.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsByIdImagesByType.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/Images/{}",
                    parameters: [
                        input.path.Id,
                        input.path._Type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Index",
                    value: input.query.Index
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .binary(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/octet-stream"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `DELETE /Items/{Id}/Images/{Type}`.
    /// - Remark: Generated from `#/paths//Items/{Id}/Images/{Type}/delete(deleteItemsByIdImagesByType)`.
    internal func deleteItemsByIdImagesByType(_ input: Operations.deleteItemsByIdImagesByType.Input) async throws -> Operations.deleteItemsByIdImagesByType.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteItemsByIdImagesByType.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/Images/{}",
                    parameters: [
                        input.path.Id,
                        input.path._Type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Index",
                    value: input.query.Index
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Items/{Id}/Images/{Type}`.
    /// - Remark: Generated from `#/paths//Items/{Id}/Images/{Type}/head(headItemsByIdImagesByType)`.
    internal func headItemsByIdImagesByType(_ input: Operations.headItemsByIdImagesByType.Input) async throws -> Operations.headItemsByIdImagesByType.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headItemsByIdImagesByType.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/Images/{}",
                    parameters: [
                        input.path.Id,
                        input.path._Type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Index",
                    value: input.query.Index
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets available remote image providers for an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Items/{Id}/RemoteImages/Providers`.
    /// - Remark: Generated from `#/paths//Items/{Id}/RemoteImages/Providers/get(getItemsByIdRemoteimagesProviders)`.
    internal func getItemsByIdRemoteimagesProviders(_ input: Operations.getItemsByIdRemoteimagesProviders.Input) async throws -> Operations.getItemsByIdRemoteimagesProviders.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsByIdRemoteimagesProviders.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/RemoteImages/Providers",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItemsByIdRemoteimagesProviders.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.ImageProviderInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Downloads a remote image for an item
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Items/{Id}/RemoteImages/Download`.
    /// - Remark: Generated from `#/paths//Items/{Id}/RemoteImages/Download/post(postItemsByIdRemoteimagesDownload)`.
    internal func postItemsByIdRemoteimagesDownload(_ input: Operations.postItemsByIdRemoteimagesDownload.Input) async throws -> Operations.postItemsByIdRemoteimagesDownload.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsByIdRemoteimagesDownload.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/RemoteImages/Download",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Type",
                    value: input.query._Type
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProviderName",
                    value: input.query.ProviderName
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageUrl",
                    value: input.query.ImageUrl
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Library/VirtualFolders/Paths/Update`.
    /// - Remark: Generated from `#/paths//Library/VirtualFolders/Paths/Update/post(postLibraryVirtualfoldersPathsUpdate)`.
    internal func postLibraryVirtualfoldersPathsUpdate(_ input: Operations.postLibraryVirtualfoldersPathsUpdate.Input) async throws -> Operations.postLibraryVirtualfoldersPathsUpdate.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLibraryVirtualfoldersPathsUpdate.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Library/VirtualFolders/Paths/Update",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Library/VirtualFolders/Paths/Delete`.
    /// - Remark: Generated from `#/paths//Library/VirtualFolders/Paths/Delete/post(postLibraryVirtualfoldersPathsDelete)`.
    internal func postLibraryVirtualfoldersPathsDelete(_ input: Operations.postLibraryVirtualfoldersPathsDelete.Input) async throws -> Operations.postLibraryVirtualfoldersPathsDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLibraryVirtualfoldersPathsDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Library/VirtualFolders/Paths/Delete",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a live tv channel
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/LiveStreamFiles/{Id}/stream.{Container}`.
    /// - Remark: Generated from `#/paths//LiveTv/LiveStreamFiles/{Id}/stream.{Container}/get(getLivetvLivestreamfilesByIdStreamByContainer)`.
    internal func getLivetvLivestreamfilesByIdStreamByContainer(_ input: Operations.getLivetvLivestreamfilesByIdStreamByContainer.Input) async throws -> Operations.getLivetvLivestreamfilesByIdStreamByContainer.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvLivestreamfilesByIdStreamByContainer.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/LiveStreamFiles/{}/stream.{}",
                    parameters: [
                        input.path.Id,
                        input.path.Container
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a live tv channel
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/LiveRecordings/{Id}/stream`.
    /// - Remark: Generated from `#/paths//LiveTv/LiveRecordings/{Id}/stream/get(getLivetvLiverecordingsByIdStream)`.
    internal func getLivetvLiverecordingsByIdStream(_ input: Operations.getLivetvLiverecordingsByIdStream.Input) async throws -> Operations.getLivetvLiverecordingsByIdStream.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvLiverecordingsByIdStream.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/LiveRecordings/{}/stream",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets available lineups
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /LiveTv/ListingProviders/SchedulesDirect/Countries`.
    /// - Remark: Generated from `#/paths//LiveTv/ListingProviders/SchedulesDirect/Countries/get(getLivetvListingprovidersSchedulesdirectCountries)`.
    internal func getLivetvListingprovidersSchedulesdirectCountries(_ input: Operations.getLivetvListingprovidersSchedulesdirectCountries.Input) async throws -> Operations.getLivetvListingprovidersSchedulesdirectCountries.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvListingprovidersSchedulesdirectCountries.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/ListingProviders/SchedulesDirect/Countries",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets tuner hosts
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /LiveTv/TunerHosts/Default/{Type}`.
    /// - Remark: Generated from `#/paths//LiveTv/TunerHosts/Default/{Type}/get(getLivetvTunerhostsDefaultByType)`.
    internal func getLivetvTunerhostsDefaultByType(_ input: Operations.getLivetvTunerhostsDefaultByType.Input) async throws -> Operations.getLivetvTunerhostsDefaultByType.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvTunerhostsDefaultByType.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/TunerHosts/Default/{}",
                    parameters: [
                        input.path._Type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getLivetvTunerhostsDefaultByType.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LiveTv_period_TunerHostInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deletes a live tv recording
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /LiveTv/Recordings/{Id}/Delete`.
    /// - Remark: Generated from `#/paths//LiveTv/Recordings/{Id}/Delete/post(postLivetvRecordingsByIdDelete)`.
    internal func postLivetvRecordingsByIdDelete(_ input: Operations.postLivetvRecordingsByIdDelete.Input) async throws -> Operations.postLivetvRecordingsByIdDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLivetvRecordingsByIdDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Recordings/{}/Delete",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Cancels a live tv timer
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /LiveTv/Timers/{Id}/Delete`.
    /// - Remark: Generated from `#/paths//LiveTv/Timers/{Id}/Delete/post(postLivetvTimersByIdDelete)`.
    internal func postLivetvTimersByIdDelete(_ input: Operations.postLivetvTimersByIdDelete.Input) async throws -> Operations.postLivetvTimersByIdDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLivetvTimersByIdDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Timers/{}/Delete",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Cancels a live tv series timer
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /LiveTv/SeriesTimers/{Id}/Delete`.
    /// - Remark: Generated from `#/paths//LiveTv/SeriesTimers/{Id}/Delete/post(postLivetvSeriestimersByIdDelete)`.
    internal func postLivetvSeriestimersByIdDelete(_ input: Operations.postLivetvSeriestimersByIdDelete.Input) async throws -> Operations.postLivetvSeriestimersByIdDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLivetvSeriestimersByIdDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/SeriesTimers/{}/Delete",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Resets a tv tuner
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /LiveTv/Tuners/{Id}/Reset`.
    /// - Remark: Generated from `#/paths//LiveTv/Tuners/{Id}/Reset/post(postLivetvTunersByIdReset)`.
    internal func postLivetvTunersByIdReset(_ input: Operations.postLivetvTunersByIdReset.Input) async throws -> Operations.postLivetvTunersByIdReset.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLivetvTunersByIdReset.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Tuners/{}/Reset",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /MusicGenres/{Name}/Images/{Type}`.
    /// - Remark: Generated from `#/paths//MusicGenres/{Name}/Images/{Type}/get(getMusicgenresByNameImagesByType)`.
    internal func getMusicgenresByNameImagesByType(_ input: Operations.getMusicgenresByNameImagesByType.Input) async throws -> Operations.getMusicgenresByNameImagesByType.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getMusicgenresByNameImagesByType.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/MusicGenres/{}/Images/{}",
                    parameters: [
                        input.path.Name,
                        input.path._Type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Index",
                    value: input.query.Index
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /MusicGenres/{Name}/Images/{Type}`.
    /// - Remark: Generated from `#/paths//MusicGenres/{Name}/Images/{Type}/head(headMusicgenresByNameImagesByType)`.
    internal func headMusicgenresByNameImagesByType(_ input: Operations.headMusicgenresByNameImagesByType.Input) async throws -> Operations.headMusicgenresByNameImagesByType.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headMusicgenresByNameImagesByType.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/MusicGenres/{}/Images/{}",
                    parameters: [
                        input.path.Name,
                        input.path._Type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Index",
                    value: input.query.Index
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Cancels a package installation
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Packages/Installing/{Id}/Delete`.
    /// - Remark: Generated from `#/paths//Packages/Installing/{Id}/Delete/post(postPackagesInstallingByIdDelete)`.
    internal func postPackagesInstallingByIdDelete(_ input: Operations.postPackagesInstallingByIdDelete.Input) async throws -> Operations.postPackagesInstallingByIdDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postPackagesInstallingByIdDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Packages/Installing/{}/Delete",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Persons/{Name}/Images/{Type}`.
    /// - Remark: Generated from `#/paths//Persons/{Name}/Images/{Type}/get(getPersonsByNameImagesByType)`.
    internal func getPersonsByNameImagesByType(_ input: Operations.getPersonsByNameImagesByType.Input) async throws -> Operations.getPersonsByNameImagesByType.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getPersonsByNameImagesByType.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Persons/{}/Images/{}",
                    parameters: [
                        input.path.Name,
                        input.path._Type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Index",
                    value: input.query.Index
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Persons/{Name}/Images/{Type}`.
    /// - Remark: Generated from `#/paths//Persons/{Name}/Images/{Type}/head(headPersonsByNameImagesByType)`.
    internal func headPersonsByNameImagesByType(_ input: Operations.headPersonsByNameImagesByType.Input) async throws -> Operations.headPersonsByNameImagesByType.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headPersonsByNameImagesByType.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Persons/{}/Images/{}",
                    parameters: [
                        input.path.Name,
                        input.path._Type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Index",
                    value: input.query.Index
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Removes items from a playlist
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Playlists/{Id}/Items/Delete`.
    /// - Remark: Generated from `#/paths//Playlists/{Id}/Items/Delete/post(postPlaylistsByIdItemsDelete)`.
    internal func postPlaylistsByIdItemsDelete(_ input: Operations.postPlaylistsByIdItemsDelete.Input) async throws -> Operations.postPlaylistsByIdItemsDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postPlaylistsByIdItemsDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Playlists/{}/Items/Delete",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EntryIds",
                    value: input.query.EntryIds
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Providers/Subtitles/Subtitles/{Id}`.
    /// - Remark: Generated from `#/paths//Providers/Subtitles/Subtitles/{Id}/get(getProvidersSubtitlesSubtitlesById)`.
    internal func getProvidersSubtitlesSubtitlesById(_ input: Operations.getProvidersSubtitlesSubtitlesById.Input) async throws -> Operations.getProvidersSubtitlesSubtitlesById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getProvidersSubtitlesSubtitlesById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Providers/Subtitles/Subtitles/{}",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Stops a scheduled task
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /ScheduledTasks/Running/{Id}/Delete`.
    /// - Remark: Generated from `#/paths//ScheduledTasks/Running/{Id}/Delete/post(postScheduledtasksRunningByIdDelete)`.
    internal func postScheduledtasksRunningByIdDelete(_ input: Operations.postScheduledtasksRunningByIdDelete.Input) async throws -> Operations.postScheduledtasksRunningByIdDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postScheduledtasksRunningByIdDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/ScheduledTasks/Running/{}/Delete",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Issues a playstate command to a client
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sessions/{Id}/Playing/{Command}`.
    /// - Remark: Generated from `#/paths//Sessions/{Id}/Playing/{Command}/post(postSessionsByIdPlayingByCommand)`.
    internal func postSessionsByIdPlayingByCommand(_ input: Operations.postSessionsByIdPlayingByCommand.Input) async throws -> Operations.postSessionsByIdPlayingByCommand.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSessionsByIdPlayingByCommand.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sessions/{}/Playing/{}",
                    parameters: [
                        input.path.Id,
                        input.path.Command
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Issues a system command to a client
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sessions/{Id}/System/{Command}`.
    /// - Remark: Generated from `#/paths//Sessions/{Id}/System/{Command}/post(postSessionsByIdSystemByCommand)`.
    internal func postSessionsByIdSystemByCommand(_ input: Operations.postSessionsByIdSystemByCommand.Input) async throws -> Operations.postSessionsByIdSystemByCommand.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSessionsByIdSystemByCommand.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sessions/{}/System/{}",
                    parameters: [
                        input.path.Id,
                        input.path.Command
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Issues a system command to a client
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sessions/{Id}/Command/{Command}`.
    /// - Remark: Generated from `#/paths//Sessions/{Id}/Command/{Command}/post(postSessionsByIdCommandByCommand)`.
    internal func postSessionsByIdCommandByCommand(_ input: Operations.postSessionsByIdCommandByCommand.Input) async throws -> Operations.postSessionsByIdCommandByCommand.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSessionsByIdCommandByCommand.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sessions/{}/Command/{}",
                    parameters: [
                        input.path.Id,
                        input.path.Command
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Adds an additional user to a session
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sessions/{Id}/Users/{UserId}`.
    /// - Remark: Generated from `#/paths//Sessions/{Id}/Users/{UserId}/post(postSessionsByIdUsersByUserid)`.
    internal func postSessionsByIdUsersByUserid(_ input: Operations.postSessionsByIdUsersByUserid.Input) async throws -> Operations.postSessionsByIdUsersByUserid.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSessionsByIdUsersByUserid.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sessions/{}/Users/{}",
                    parameters: [
                        input.path.Id,
                        input.path.UserId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Removes an additional user from a session
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `DELETE /Sessions/{Id}/Users/{UserId}`.
    /// - Remark: Generated from `#/paths//Sessions/{Id}/Users/{UserId}/delete(deleteSessionsByIdUsersByUserid)`.
    internal func deleteSessionsByIdUsersByUserid(_ input: Operations.deleteSessionsByIdUsersByUserid.Input) async throws -> Operations.deleteSessionsByIdUsersByUserid.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteSessionsByIdUsersByUserid.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sessions/{}/Users/{}",
                    parameters: [
                        input.path.Id,
                        input.path.UserId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Studios/{Name}/Images/{Type}`.
    /// - Remark: Generated from `#/paths//Studios/{Name}/Images/{Type}/get(getStudiosByNameImagesByType)`.
    internal func getStudiosByNameImagesByType(_ input: Operations.getStudiosByNameImagesByType.Input) async throws -> Operations.getStudiosByNameImagesByType.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getStudiosByNameImagesByType.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Studios/{}/Images/{}",
                    parameters: [
                        input.path.Name,
                        input.path._Type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Index",
                    value: input.query.Index
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Studios/{Name}/Images/{Type}`.
    /// - Remark: Generated from `#/paths//Studios/{Name}/Images/{Type}/head(headStudiosByNameImagesByType)`.
    internal func headStudiosByNameImagesByType(_ input: Operations.headStudiosByNameImagesByType.Input) async throws -> Operations.headStudiosByNameImagesByType.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headStudiosByNameImagesByType.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Studios/{}/Images/{}",
                    parameters: [
                        input.path.Name,
                        input.path._Type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Index",
                    value: input.query.Index
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Cancels a sync job.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sync/Jobs/{Id}/Delete`.
    /// - Remark: Generated from `#/paths//Sync/Jobs/{Id}/Delete/post(postSyncJobsByIdDelete)`.
    internal func postSyncJobsByIdDelete(_ input: Operations.postSyncJobsByIdDelete.Input) async throws -> Operations.postSyncJobsByIdDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSyncJobsByIdDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sync/Jobs/{}/Delete",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Cancels items from a sync target
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sync/{TargetId}/Items/Delete`.
    /// - Remark: Generated from `#/paths//Sync/{TargetId}/Items/Delete/post(postSyncByTargetidItemsDelete)`.
    internal func postSyncByTargetidItemsDelete(_ input: Operations.postSyncByTargetidItemsDelete.Input) async throws -> Operations.postSyncByTargetidItemsDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSyncByTargetidItemsDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sync/{}/Items/Delete",
                    parameters: [
                        input.path.TargetId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ItemIds",
                    value: input.query.ItemIds
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Reports that a sync job item has successfully been transferred.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sync/JobItems/{Id}/Transferred`.
    /// - Remark: Generated from `#/paths//Sync/JobItems/{Id}/Transferred/post(postSyncJobitemsByIdTransferred)`.
    internal func postSyncJobitemsByIdTransferred(_ input: Operations.postSyncJobitemsByIdTransferred.Input) async throws -> Operations.postSyncJobitemsByIdTransferred.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSyncJobitemsByIdTransferred.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sync/JobItems/{}/Transferred",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a sync job item file
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Sync/JobItems/{Id}/File`.
    /// - Remark: Generated from `#/paths//Sync/JobItems/{Id}/File/get(getSyncJobitemsByIdFile)`.
    internal func getSyncJobitemsByIdFile(_ input: Operations.getSyncJobitemsByIdFile.Input) async throws -> Operations.getSyncJobitemsByIdFile.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSyncJobitemsByIdFile.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sync/JobItems/{}/File",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a sync job item file
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Sync/JobItems/{Id}/File`.
    /// - Remark: Generated from `#/paths//Sync/JobItems/{Id}/File/head(headSyncJobitemsByIdFile)`.
    internal func headSyncJobitemsByIdFile(_ input: Operations.headSyncJobitemsByIdFile.Input) async throws -> Operations.headSyncJobitemsByIdFile.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headSyncJobitemsByIdFile.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sync/JobItems/{}/File",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a sync job item file
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Sync/JobItems/{Id}/AdditionalFiles`.
    /// - Remark: Generated from `#/paths//Sync/JobItems/{Id}/AdditionalFiles/get(getSyncJobitemsByIdAdditionalfiles)`.
    internal func getSyncJobitemsByIdAdditionalfiles(_ input: Operations.getSyncJobitemsByIdAdditionalfiles.Input) async throws -> Operations.getSyncJobitemsByIdAdditionalfiles.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSyncJobitemsByIdAdditionalfiles.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sync/JobItems/{}/AdditionalFiles",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Name",
                    value: input.query.Name
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Enables a cancelled or queued sync job item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sync/JobItems/{Id}/Enable`.
    /// - Remark: Generated from `#/paths//Sync/JobItems/{Id}/Enable/post(postSyncJobitemsByIdEnable)`.
    internal func postSyncJobitemsByIdEnable(_ input: Operations.postSyncJobitemsByIdEnable.Input) async throws -> Operations.postSyncJobitemsByIdEnable.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSyncJobitemsByIdEnable.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sync/JobItems/{}/Enable",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Cancels a sync job item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sync/JobItems/{Id}/Delete`.
    /// - Remark: Generated from `#/paths//Sync/JobItems/{Id}/Delete/post(postSyncJobitemsByIdDelete)`.
    internal func postSyncJobitemsByIdDelete(_ input: Operations.postSyncJobitemsByIdDelete.Input) async throws -> Operations.postSyncJobitemsByIdDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSyncJobitemsByIdDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sync/JobItems/{}/Delete",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Marks a job item for removal
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sync/JobItems/{Id}/MarkForRemoval`.
    /// - Remark: Generated from `#/paths//Sync/JobItems/{Id}/MarkForRemoval/post(postSyncJobitemsByIdMarkforremoval)`.
    internal func postSyncJobitemsByIdMarkforremoval(_ input: Operations.postSyncJobitemsByIdMarkforremoval.Input) async throws -> Operations.postSyncJobitemsByIdMarkforremoval.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSyncJobitemsByIdMarkforremoval.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sync/JobItems/{}/MarkForRemoval",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Unmarks a job item for removal
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sync/JobItems/{Id}/UnmarkForRemoval`.
    /// - Remark: Generated from `#/paths//Sync/JobItems/{Id}/UnmarkForRemoval/post(postSyncJobitemsByIdUnmarkforremoval)`.
    internal func postSyncJobitemsByIdUnmarkforremoval(_ input: Operations.postSyncJobitemsByIdUnmarkforremoval.Input) async throws -> Operations.postSyncJobitemsByIdUnmarkforremoval.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSyncJobitemsByIdUnmarkforremoval.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sync/JobItems/{}/UnmarkForRemoval",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a log file
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `GET /System/Logs/{Name}/Lines`.
    /// - Remark: Generated from `#/paths//System/Logs/{Name}/Lines/get(getSystemLogsByNameLines)`.
    internal func getSystemLogsByNameLines(_ input: Operations.getSystemLogsByNameLines.Input) async throws -> Operations.getSystemLogsByNameLines.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSystemLogsByNameLines.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/Logs/{}/Lines",
                    parameters: [
                        input.path.Name
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSystemLogsByNameLines.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_String.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Clears audio or subtitle track selections for a user
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `DELETE /Users/{Id}/TrackSelections/{TrackType}`.
    /// - Remark: Generated from `#/paths//Users/{Id}/TrackSelections/{TrackType}/delete(deleteUsersByIdTrackselectionsByTracktype)`.
    internal func deleteUsersByIdTrackselectionsByTracktype(_ input: Operations.deleteUsersByIdTrackselectionsByTracktype.Input) async throws -> Operations.deleteUsersByIdTrackselectionsByTracktype.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteUsersByIdTrackselectionsByTracktype.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/TrackSelections/{}",
                    parameters: [
                        input.path.Id,
                        input.path.TrackType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates a user configuration
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{Id}/Configuration/Partial`.
    /// - Remark: Generated from `#/paths//Users/{Id}/Configuration/Partial/post(postUsersByIdConfigurationPartial)`.
    internal func postUsersByIdConfigurationPartial(_ input: Operations.postUsersByIdConfigurationPartial.Input) async throws -> Operations.postUsersByIdConfigurationPartial.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByIdConfigurationPartial.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Configuration/Partial",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .binary(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/octet-stream"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a typed user setting
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Users/{UserId}/TypedSettings/{Key}`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/TypedSettings/{Key}/get(getUsersByUseridTypedsettingsByKey)`.
    internal func getUsersByUseridTypedsettingsByKey(_ input: Operations.getUsersByUseridTypedsettingsByKey.Input) async throws -> Operations.getUsersByUseridTypedsettingsByKey.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUsersByUseridTypedsettingsByKey.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/TypedSettings/{}",
                    parameters: [
                        input.path.UserId,
                        input.path.Key
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates a typed user setting
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{UserId}/TypedSettings/{Key}`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/TypedSettings/{Key}/post(postUsersByUseridTypedsettingsByKey)`.
    internal func postUsersByUseridTypedsettingsByKey(_ input: Operations.postUsersByUseridTypedsettingsByKey.Input) async throws -> Operations.postUsersByUseridTypedsettingsByKey.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByUseridTypedsettingsByKey.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/TypedSettings/{}",
                    parameters: [
                        input.path.UserId,
                        input.path.Key
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .binary(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/octet-stream"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets items based on a query.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Users/{UserId}/Items/Resume`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/Items/Resume/get(getUsersByUseridItemsResume)`.
    internal func getUsersByUseridItemsResume(_ input: Operations.getUsersByUseridItemsResume.Input) async throws -> Operations.getUsersByUseridItemsResume.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUsersByUseridItemsResume.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Items/Resume",
                    parameters: [
                        input.path.UserId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistType",
                    value: input.query.ArtistType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxOfficialRating",
                    value: input.query.MaxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeSong",
                    value: input.query.HasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasThemeVideo",
                    value: input.query.HasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSubtitles",
                    value: input.query.HasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasSpecialFeature",
                    value: input.query.HasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTrailer",
                    value: input.query.HasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AdjacentTo",
                    value: input.query.AdjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinIndexNumber",
                    value: input.query.MinIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinStartDate",
                    value: input.query.MinStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxStartDate",
                    value: input.query.MaxStartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinEndDate",
                    value: input.query.MinEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxEndDate",
                    value: input.query.MaxEndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPlayers",
                    value: input.query.MinPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPlayers",
                    value: input.query.MaxPlayers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentIndexNumber",
                    value: input.query.ParentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasParentalRating",
                    value: input.query.HasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHD",
                    value: input.query.IsHD
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsUnaired",
                    value: input.query.IsUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCommunityRating",
                    value: input.query.MinCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinCriticRating",
                    value: input.query.MinCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AiredDuringSeason",
                    value: input.query.AiredDuringSeason
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinPremiereDate",
                    value: input.query.MinPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSaved",
                    value: input.query.MinDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinDateLastSavedForUser",
                    value: input.query.MinDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxPremiereDate",
                    value: input.query.MaxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOverview",
                    value: input.query.HasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasImdbId",
                    value: input.query.HasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTmdbId",
                    value: input.query.HasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasTvdbId",
                    value: input.query.HasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemIds",
                    value: input.query.ExcludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartIndex",
                    value: input.query.StartIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Recursive",
                    value: input.query.Recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SearchTerm",
                    value: input.query.SearchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SortOrder",
                    value: input.query.SortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeItemTypes",
                    value: input.query.ExcludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AnyProviderIdEquals",
                    value: input.query.AnyProviderIdEquals
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Filters",
                    value: input.query.Filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFavorite",
                    value: input.query.IsFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMovie",
                    value: input.query.IsMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSeries",
                    value: input.query.IsSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNews",
                    value: input.query.IsNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsKids",
                    value: input.query.IsKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsSports",
                    value: input.query.IsSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNew",
                    value: input.query.IsNew
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPremiere",
                    value: input.query.IsPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsNewOrPremiere",
                    value: input.query.IsNewOrPremiere
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsRepeat",
                    value: input.query.IsRepeat
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ProjectToMedia",
                    value: input.query.ProjectToMedia
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ImageTypes",
                    value: input.query.ImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SortBy",
                    value: input.query.SortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Genres",
                    value: input.query.Genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "OfficialRatings",
                    value: input.query.OfficialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Tags",
                    value: input.query.Tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExcludeTags",
                    value: input.query.ExcludeTags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Years",
                    value: input.query.Years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Person",
                    value: input.query.Person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonIds",
                    value: input.query.PersonIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PersonTypes",
                    value: input.query.PersonTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Studios",
                    value: input.query.Studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StudioIds",
                    value: input.query.StudioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Artists",
                    value: input.query.Artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ArtistIds",
                    value: input.query.ArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Albums",
                    value: input.query.Albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Ids",
                    value: input.query.Ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoTypes",
                    value: input.query.VideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Containers",
                    value: input.query.Containers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioCodecs",
                    value: input.query.AudioCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AudioLayouts",
                    value: input.query.AudioLayouts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "VideoCodecs",
                    value: input.query.VideoCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ExtendedVideoTypes",
                    value: input.query.ExtendedVideoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SubtitleCodecs",
                    value: input.query.SubtitleCodecs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Path",
                    value: input.query.Path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MinOfficialRating",
                    value: input.query.MinOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsLocked",
                    value: input.query.IsLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlaceHolder",
                    value: input.query.IsPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "HasOfficialRating",
                    value: input.query.HasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItemsIntoCollections",
                    value: input.query.GroupItemsIntoCollections
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Is3D",
                    value: input.query.Is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "SeriesStatus",
                    value: input.query.SeriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWithOrGreater",
                    value: input.query.NameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ArtistStartsWithOrGreater",
                    value: input.query.ArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AlbumArtistStartsWithOrGreater",
                    value: input.query.AlbumArtistStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameStartsWith",
                    value: input.query.NameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NameLessThan",
                    value: input.query.NameLessThan
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getUsersByUseridItemsResume.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets latest media
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Users/{UserId}/Items/Latest`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/Items/Latest/get(getUsersByUseridItemsLatest)`.
    internal func getUsersByUseridItemsLatest(_ input: Operations.getUsersByUseridItemsLatest.Input) async throws -> Operations.getUsersByUseridItemsLatest.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUsersByUseridItemsLatest.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Items/Latest",
                    parameters: [
                        input.path.UserId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Limit",
                    value: input.query.Limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ParentId",
                    value: input.query.ParentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IncludeItemTypes",
                    value: input.query.IncludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "MediaTypes",
                    value: input.query.MediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsFolder",
                    value: input.query.IsFolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPlayed",
                    value: input.query.IsPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "GroupItems",
                    value: input.query.GroupItems
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getUsersByUseridItemsLatest.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.BaseItemDto].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets an item from a user's library
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Users/{UserId}/Items/{Id}`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/Items/{Id}/get(getUsersByUseridItemsById)`.
    internal func getUsersByUseridItemsById(_ input: Operations.getUsersByUseridItemsById.Input) async throws -> Operations.getUsersByUseridItemsById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUsersByUseridItemsById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Items/{}",
                    parameters: [
                        input.path.UserId,
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getUsersByUseridItemsById.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets the root folder from a user's library
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Users/{UserId}/Items/Root`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/Items/Root/get(getUsersByUseridItemsRoot)`.
    internal func getUsersByUseridItemsRoot(_ input: Operations.getUsersByUseridItemsRoot.Input) async throws -> Operations.getUsersByUseridItemsRoot.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUsersByUseridItemsRoot.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Items/Root",
                    parameters: [
                        input.path.UserId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getUsersByUseridItemsRoot.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Marks an item as a favorite
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{UserId}/FavoriteItems/{Id}`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/FavoriteItems/{Id}/post(postUsersByUseridFavoriteitemsById)`.
    internal func postUsersByUseridFavoriteitemsById(_ input: Operations.postUsersByUseridFavoriteitemsById.Input) async throws -> Operations.postUsersByUseridFavoriteitemsById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByUseridFavoriteitemsById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/FavoriteItems/{}",
                    parameters: [
                        input.path.UserId,
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postUsersByUseridFavoriteitemsById.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserItemDataDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Unmarks an item as a favorite
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `DELETE /Users/{UserId}/FavoriteItems/{Id}`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/FavoriteItems/{Id}/delete(deleteUsersByUseridFavoriteitemsById)`.
    internal func deleteUsersByUseridFavoriteitemsById(_ input: Operations.deleteUsersByUseridFavoriteitemsById.Input) async throws -> Operations.deleteUsersByUseridFavoriteitemsById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteUsersByUseridFavoriteitemsById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/FavoriteItems/{}",
                    parameters: [
                        input.path.UserId,
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.deleteUsersByUseridFavoriteitemsById.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserItemDataDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Users/{Id}/Images/{Type}`.
    /// - Remark: Generated from `#/paths//Users/{Id}/Images/{Type}/get(getUsersByIdImagesByType)`.
    internal func getUsersByIdImagesByType(_ input: Operations.getUsersByIdImagesByType.Input) async throws -> Operations.getUsersByIdImagesByType.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUsersByIdImagesByType.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Images/{}",
                    parameters: [
                        input.path.Id,
                        input.path._Type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Index",
                    value: input.query.Index
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Uploads an image for an item, must be base64 encoded.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{Id}/Images/{Type}`.
    /// - Remark: Generated from `#/paths//Users/{Id}/Images/{Type}/post(postUsersByIdImagesByType)`.
    internal func postUsersByIdImagesByType(_ input: Operations.postUsersByIdImagesByType.Input) async throws -> Operations.postUsersByIdImagesByType.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByIdImagesByType.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Images/{}",
                    parameters: [
                        input.path.Id,
                        input.path._Type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Index",
                    value: input.query.Index
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .binary(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/octet-stream"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `DELETE /Users/{Id}/Images/{Type}`.
    /// - Remark: Generated from `#/paths//Users/{Id}/Images/{Type}/delete(deleteUsersByIdImagesByType)`.
    internal func deleteUsersByIdImagesByType(_ input: Operations.deleteUsersByIdImagesByType.Input) async throws -> Operations.deleteUsersByIdImagesByType.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteUsersByIdImagesByType.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Images/{}",
                    parameters: [
                        input.path.Id,
                        input.path._Type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Index",
                    value: input.query.Index
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Users/{Id}/Images/{Type}`.
    /// - Remark: Generated from `#/paths//Users/{Id}/Images/{Type}/head(headUsersByIdImagesByType)`.
    internal func headUsersByIdImagesByType(_ input: Operations.headUsersByIdImagesByType.Input) async throws -> Operations.headUsersByIdImagesByType.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headUsersByIdImagesByType.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Images/{}",
                    parameters: [
                        input.path.Id,
                        input.path._Type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Index",
                    value: input.query.Index
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Marks an item as played
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{UserId}/PlayedItems/{Id}`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/PlayedItems/{Id}/post(postUsersByUseridPlayeditemsById)`.
    internal func postUsersByUseridPlayeditemsById(_ input: Operations.postUsersByUseridPlayeditemsById.Input) async throws -> Operations.postUsersByUseridPlayeditemsById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByUseridPlayeditemsById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/PlayedItems/{}",
                    parameters: [
                        input.path.UserId,
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "DatePlayed",
                    value: input.query.DatePlayed
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postUsersByUseridPlayeditemsById.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserItemDataDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Marks an item as unplayed
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `DELETE /Users/{UserId}/PlayedItems/{Id}`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/PlayedItems/{Id}/delete(deleteUsersByUseridPlayeditemsById)`.
    internal func deleteUsersByUseridPlayeditemsById(_ input: Operations.deleteUsersByUseridPlayeditemsById.Input) async throws -> Operations.deleteUsersByUseridPlayeditemsById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteUsersByUseridPlayeditemsById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/PlayedItems/{}",
                    parameters: [
                        input.path.UserId,
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.deleteUsersByUseridPlayeditemsById.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserItemDataDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Reports that a user has begun playing an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{UserId}/PlayingItems/{Id}`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/PlayingItems/{Id}/post(postUsersByUseridPlayingitemsById)`.
    internal func postUsersByUseridPlayingitemsById(_ input: Operations.postUsersByUseridPlayingitemsById.Input) async throws -> Operations.postUsersByUseridPlayingitemsById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByUseridPlayingitemsById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/PlayingItems/{}",
                    parameters: [
                        input.path.UserId,
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MediaSourceId",
                    value: input.query.MediaSourceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CanSeek",
                    value: input.query.CanSeek
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioStreamIndex",
                    value: input.query.AudioStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleStreamIndex",
                    value: input.query.SubtitleStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PlayMethod",
                    value: input.query.PlayMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "LiveStreamId",
                    value: input.query.LiveStreamId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PlaySessionId",
                    value: input.query.PlaySessionId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Reports that a user has stopped playing an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `DELETE /Users/{UserId}/PlayingItems/{Id}`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/PlayingItems/{Id}/delete(deleteUsersByUseridPlayingitemsById)`.
    internal func deleteUsersByUseridPlayingitemsById(_ input: Operations.deleteUsersByUseridPlayingitemsById.Input) async throws -> Operations.deleteUsersByUseridPlayingitemsById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteUsersByUseridPlayingitemsById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/PlayingItems/{}",
                    parameters: [
                        input.path.UserId,
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MediaSourceId",
                    value: input.query.MediaSourceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NextMediaType",
                    value: input.query.NextMediaType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PositionTicks",
                    value: input.query.PositionTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "LiveStreamId",
                    value: input.query.LiveStreamId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PlaySessionId",
                    value: input.query.PlaySessionId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Creates a Connect link for a user
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Users/{Id}/Connect/Link`.
    /// - Remark: Generated from `#/paths//Users/{Id}/Connect/Link/post(postUsersByIdConnectLink)`.
    internal func postUsersByIdConnectLink(_ input: Operations.postUsersByIdConnectLink.Input) async throws -> Operations.postUsersByIdConnectLink.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByIdConnectLink.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Connect/Link",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ConnectUsername",
                    value: input.query.ConnectUsername
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postUsersByIdConnectLink.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Connect_period_UserLinkResult.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Removes a Connect link for a user
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `DELETE /Users/{Id}/Connect/Link`.
    /// - Remark: Generated from `#/paths//Users/{Id}/Connect/Link/delete(deleteUsersByIdConnectLink)`.
    internal func deleteUsersByIdConnectLink(_ input: Operations.deleteUsersByIdConnectLink.Input) async throws -> Operations.deleteUsersByIdConnectLink.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteUsersByIdConnectLink.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Connect/Link",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Removes alternate video sources.
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Videos/{Id}/AlternateSources/Delete`.
    /// - Remark: Generated from `#/paths//Videos/{Id}/AlternateSources/Delete/post(postVideosByIdAlternatesourcesDelete)`.
    internal func postVideosByIdAlternatesourcesDelete(_ input: Operations.postVideosByIdAlternatesourcesDelete.Input) async throws -> Operations.postVideosByIdAlternatesourcesDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postVideosByIdAlternatesourcesDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/{}/AlternateSources/Delete",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deletes an external subtitle file
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `DELETE /Videos/{Id}/Subtitles/{Index}`.
    /// - Remark: Generated from `#/paths//Videos/{Id}/Subtitles/{Index}/delete(deleteVideosByIdSubtitlesByIndex)`.
    internal func deleteVideosByIdSubtitlesByIndex(_ input: Operations.deleteVideosByIdSubtitlesByIndex.Input) async throws -> Operations.deleteVideosByIdSubtitlesByIndex.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteVideosByIdSubtitlesByIndex.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/{}/Subtitles/{}",
                    parameters: [
                        input.path.Id,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MediaSourceId",
                    value: input.query.MediaSourceId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Artists/{Name}/Images/{Type}/{Index}`.
    /// - Remark: Generated from `#/paths//Artists/{Name}/Images/{Type}/{Index}/get(getArtistsByNameImagesByTypeByIndex)`.
    internal func getArtistsByNameImagesByTypeByIndex(_ input: Operations.getArtistsByNameImagesByTypeByIndex.Input) async throws -> Operations.getArtistsByNameImagesByTypeByIndex.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getArtistsByNameImagesByTypeByIndex.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Artists/{}/Images/{}/{}",
                    parameters: [
                        input.path.Name,
                        input.path._Type,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Artists/{Name}/Images/{Type}/{Index}`.
    /// - Remark: Generated from `#/paths//Artists/{Name}/Images/{Type}/{Index}/head(headArtistsByNameImagesByTypeByIndex)`.
    internal func headArtistsByNameImagesByTypeByIndex(_ input: Operations.headArtistsByNameImagesByTypeByIndex.Input) async throws -> Operations.headArtistsByNameImagesByTypeByIndex.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headArtistsByNameImagesByTypeByIndex.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Artists/{}/Images/{}/{}",
                    parameters: [
                        input.path.Name,
                        input.path._Type,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Audio/{Id}/hls1/{PlaylistId}/{SegmentId}.{SegmentContainer}`.
    /// - Remark: Generated from `#/paths//Audio/{Id}/hls1/{PlaylistId}/{SegmentId}.{SegmentContainer}/get(getAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainer)`.
    internal func getAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainer(_ input: Operations.getAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainer.Input) async throws -> Operations.getAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainer.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainer.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Audio/{}/hls1/{}/{}.{}",
                    parameters: [
                        input.path.Id,
                        input.path.PlaylistId,
                        input.path.SegmentId,
                        input.path.SegmentContainer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Audio/{Id}/hls1/{PlaylistId}/{SegmentId}.{SegmentContainer}`.
    /// - Remark: Generated from `#/paths//Audio/{Id}/hls1/{PlaylistId}/{SegmentId}.{SegmentContainer}/head(headAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainer)`.
    internal func headAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainer(_ input: Operations.headAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainer.Input) async throws -> Operations.headAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainer.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainer.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Audio/{}/hls1/{}/{}.{}",
                    parameters: [
                        input.path.Id,
                        input.path.PlaylistId,
                        input.path.SegmentId,
                        input.path.SegmentContainer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Audio/{Id}/hls/{PlaylistId}/{SegmentId}.{SegmentContainer}`.
    /// - Remark: Generated from `#/paths//Audio/{Id}/hls/{PlaylistId}/{SegmentId}.{SegmentContainer}/get(getAudioByIdHlsByPlaylistidBySegmentidBySegmentcontainer)`.
    internal func getAudioByIdHlsByPlaylistidBySegmentidBySegmentcontainer(_ input: Operations.getAudioByIdHlsByPlaylistidBySegmentidBySegmentcontainer.Input) async throws -> Operations.getAudioByIdHlsByPlaylistidBySegmentidBySegmentcontainer.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAudioByIdHlsByPlaylistidBySegmentidBySegmentcontainer.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Audio/{}/hls/{}/{}.{}",
                    parameters: [
                        input.path.Id,
                        input.path.PlaylistId,
                        input.path.SegmentId,
                        input.path.SegmentContainer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /GameGenres/{Name}/Images/{Type}/{Index}`.
    /// - Remark: Generated from `#/paths//GameGenres/{Name}/Images/{Type}/{Index}/get(getGamegenresByNameImagesByTypeByIndex)`.
    internal func getGamegenresByNameImagesByTypeByIndex(_ input: Operations.getGamegenresByNameImagesByTypeByIndex.Input) async throws -> Operations.getGamegenresByNameImagesByTypeByIndex.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getGamegenresByNameImagesByTypeByIndex.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/GameGenres/{}/Images/{}/{}",
                    parameters: [
                        input.path.Name,
                        input.path._Type,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /GameGenres/{Name}/Images/{Type}/{Index}`.
    /// - Remark: Generated from `#/paths//GameGenres/{Name}/Images/{Type}/{Index}/head(headGamegenresByNameImagesByTypeByIndex)`.
    internal func headGamegenresByNameImagesByTypeByIndex(_ input: Operations.headGamegenresByNameImagesByTypeByIndex.Input) async throws -> Operations.headGamegenresByNameImagesByTypeByIndex.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headGamegenresByNameImagesByTypeByIndex.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/GameGenres/{}/Images/{}/{}",
                    parameters: [
                        input.path.Name,
                        input.path._Type,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Genres/{Name}/Images/{Type}/{Index}`.
    /// - Remark: Generated from `#/paths//Genres/{Name}/Images/{Type}/{Index}/get(getGenresByNameImagesByTypeByIndex)`.
    internal func getGenresByNameImagesByTypeByIndex(_ input: Operations.getGenresByNameImagesByTypeByIndex.Input) async throws -> Operations.getGenresByNameImagesByTypeByIndex.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getGenresByNameImagesByTypeByIndex.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Genres/{}/Images/{}/{}",
                    parameters: [
                        input.path.Name,
                        input.path._Type,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Genres/{Name}/Images/{Type}/{Index}`.
    /// - Remark: Generated from `#/paths//Genres/{Name}/Images/{Type}/{Index}/head(headGenresByNameImagesByTypeByIndex)`.
    internal func headGenresByNameImagesByTypeByIndex(_ input: Operations.headGenresByNameImagesByTypeByIndex.Input) async throws -> Operations.headGenresByNameImagesByTypeByIndex.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headGenresByNameImagesByTypeByIndex.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Genres/{}/Images/{}/{}",
                    parameters: [
                        input.path.Name,
                        input.path._Type,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Items/{Id}/RemoteSearch/Subtitles/{Language}`.
    /// - Remark: Generated from `#/paths//Items/{Id}/RemoteSearch/Subtitles/{Language}/get(getItemsByIdRemotesearchSubtitlesByLanguage)`.
    internal func getItemsByIdRemotesearchSubtitlesByLanguage(_ input: Operations.getItemsByIdRemotesearchSubtitlesByLanguage.Input) async throws -> Operations.getItemsByIdRemotesearchSubtitlesByLanguage.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsByIdRemotesearchSubtitlesByLanguage.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/RemoteSearch/Subtitles/{}",
                    parameters: [
                        input.path.Id,
                        input.path.Language
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MediaSourceId",
                    value: input.query.MediaSourceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPerfectMatch",
                    value: input.query.IsPerfectMatch
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsForced",
                    value: input.query.IsForced
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsHearingImpaired",
                    value: input.query.IsHearingImpaired
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItemsByIdRemotesearchSubtitlesByLanguage.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.RemoteSubtitleInfo].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deletes an external subtitle file
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Items/{Id}/Subtitles/{Index}/Delete`.
    /// - Remark: Generated from `#/paths//Items/{Id}/Subtitles/{Index}/Delete/post(postItemsByIdSubtitlesByIndexDelete)`.
    internal func postItemsByIdSubtitlesByIndexDelete(_ input: Operations.postItemsByIdSubtitlesByIndexDelete.Input) async throws -> Operations.postItemsByIdSubtitlesByIndexDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsByIdSubtitlesByIndexDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/Subtitles/{}/Delete",
                    parameters: [
                        input.path.Id,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MediaSourceId",
                    value: input.query.MediaSourceId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Items/{Id}/RemoteSearch/Subtitles/{SubtitleId}`.
    /// - Remark: Generated from `#/paths//Items/{Id}/RemoteSearch/Subtitles/{SubtitleId}/post(postItemsByIdRemotesearchSubtitlesBySubtitleid)`.
    internal func postItemsByIdRemotesearchSubtitlesBySubtitleid(_ input: Operations.postItemsByIdRemotesearchSubtitlesBySubtitleid.Input) async throws -> Operations.postItemsByIdRemotesearchSubtitlesBySubtitleid.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsByIdRemotesearchSubtitlesBySubtitleid.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/RemoteSearch/Subtitles/{}",
                    parameters: [
                        input.path.Id,
                        input.path.SubtitleId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MediaSourceId",
                    value: input.query.MediaSourceId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postItemsByIdRemotesearchSubtitlesBySubtitleid.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Subtitles_period_SubtitleDownloadResult.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Items/{Id}/Images/{Type}/{Index}`.
    /// - Remark: Generated from `#/paths//Items/{Id}/Images/{Type}/{Index}/get(getItemsByIdImagesByTypeByIndex)`.
    internal func getItemsByIdImagesByTypeByIndex(_ input: Operations.getItemsByIdImagesByTypeByIndex.Input) async throws -> Operations.getItemsByIdImagesByTypeByIndex.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsByIdImagesByTypeByIndex.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/Images/{}/{}",
                    parameters: [
                        input.path.Id,
                        input.path._Type,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Uploads an image for an item, must be base64 encoded.
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Items/{Id}/Images/{Type}/{Index}`.
    /// - Remark: Generated from `#/paths//Items/{Id}/Images/{Type}/{Index}/post(postItemsByIdImagesByTypeByIndex)`.
    internal func postItemsByIdImagesByTypeByIndex(_ input: Operations.postItemsByIdImagesByTypeByIndex.Input) async throws -> Operations.postItemsByIdImagesByTypeByIndex.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsByIdImagesByTypeByIndex.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/Images/{}/{}",
                    parameters: [
                        input.path.Id,
                        input.path._Type,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .binary(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/octet-stream"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `DELETE /Items/{Id}/Images/{Type}/{Index}`.
    /// - Remark: Generated from `#/paths//Items/{Id}/Images/{Type}/{Index}/delete(deleteItemsByIdImagesByTypeByIndex)`.
    internal func deleteItemsByIdImagesByTypeByIndex(_ input: Operations.deleteItemsByIdImagesByTypeByIndex.Input) async throws -> Operations.deleteItemsByIdImagesByTypeByIndex.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteItemsByIdImagesByTypeByIndex.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/Images/{}/{}",
                    parameters: [
                        input.path.Id,
                        input.path._Type,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Items/{Id}/Images/{Type}/{Index}`.
    /// - Remark: Generated from `#/paths//Items/{Id}/Images/{Type}/{Index}/head(headItemsByIdImagesByTypeByIndex)`.
    internal func headItemsByIdImagesByTypeByIndex(_ input: Operations.headItemsByIdImagesByTypeByIndex.Input) async throws -> Operations.headItemsByIdImagesByTypeByIndex.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headItemsByIdImagesByTypeByIndex.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/Images/{}/{}",
                    parameters: [
                        input.path.Id,
                        input.path._Type,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Items/{Id}/Images/{Type}/Delete`.
    /// - Remark: Generated from `#/paths//Items/{Id}/Images/{Type}/Delete/post(postItemsByIdImagesByTypeDelete)`.
    internal func postItemsByIdImagesByTypeDelete(_ input: Operations.postItemsByIdImagesByTypeDelete.Input) async throws -> Operations.postItemsByIdImagesByTypeDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsByIdImagesByTypeDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/Images/{}/Delete",
                    parameters: [
                        input.path.Id,
                        input.path._Type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Index",
                    value: input.query.Index
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a live tv channel
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/LiveStreamFiles/{Id}/hls/master.m3u8`.
    /// - Remark: Generated from `#/paths//LiveTv/LiveStreamFiles/{Id}/hls/master.m3u8/get(getLivetvLivestreamfilesByIdHlsMasterM3u8)`.
    internal func getLivetvLivestreamfilesByIdHlsMasterM3u8(_ input: Operations.getLivetvLivestreamfilesByIdHlsMasterM3u8.Input) async throws -> Operations.getLivetvLivestreamfilesByIdHlsMasterM3u8.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvLivestreamfilesByIdHlsMasterM3u8.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/LiveStreamFiles/{}/hls/master.m3u8",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a live tv channel
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /LiveTv/LiveStreamFiles/{Id}/hls/master.m3u8`.
    /// - Remark: Generated from `#/paths//LiveTv/LiveStreamFiles/{Id}/hls/master.m3u8/head(headLivetvLivestreamfilesByIdHlsMasterM3u8)`.
    internal func headLivetvLivestreamfilesByIdHlsMasterM3u8(_ input: Operations.headLivetvLivestreamfilesByIdHlsMasterM3u8.Input) async throws -> Operations.headLivetvLivestreamfilesByIdHlsMasterM3u8.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headLivetvLivestreamfilesByIdHlsMasterM3u8.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/LiveStreamFiles/{}/hls/master.m3u8",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a live recording
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/LiveRecordings/{Id}/hls/master.m3u8`.
    /// - Remark: Generated from `#/paths//LiveTv/LiveRecordings/{Id}/hls/master.m3u8/get(getLivetvLiverecordingsByIdHlsMasterM3u8)`.
    internal func getLivetvLiverecordingsByIdHlsMasterM3u8(_ input: Operations.getLivetvLiverecordingsByIdHlsMasterM3u8.Input) async throws -> Operations.getLivetvLiverecordingsByIdHlsMasterM3u8.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvLiverecordingsByIdHlsMasterM3u8.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/LiveRecordings/{}/hls/master.m3u8",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a live recording
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /LiveTv/LiveRecordings/{Id}/hls/master.m3u8`.
    /// - Remark: Generated from `#/paths//LiveTv/LiveRecordings/{Id}/hls/master.m3u8/head(headLivetvLiverecordingsByIdHlsMasterM3u8)`.
    internal func headLivetvLiverecordingsByIdHlsMasterM3u8(_ input: Operations.headLivetvLiverecordingsByIdHlsMasterM3u8.Input) async throws -> Operations.headLivetvLiverecordingsByIdHlsMasterM3u8.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headLivetvLiverecordingsByIdHlsMasterM3u8.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/LiveRecordings/{}/hls/master.m3u8",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a live recording
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/LiveRecordings/{Id}/hls/live.m3u8`.
    /// - Remark: Generated from `#/paths//LiveTv/LiveRecordings/{Id}/hls/live.m3u8/get(getLivetvLiverecordingsByIdHlsLiveM3u8)`.
    internal func getLivetvLiverecordingsByIdHlsLiveM3u8(_ input: Operations.getLivetvLiverecordingsByIdHlsLiveM3u8.Input) async throws -> Operations.getLivetvLiverecordingsByIdHlsLiveM3u8.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvLiverecordingsByIdHlsLiveM3u8.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/LiveRecordings/{}/hls/live.m3u8",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a live recording
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /LiveTv/LiveRecordings/{Id}/hls/live.m3u8`.
    /// - Remark: Generated from `#/paths//LiveTv/LiveRecordings/{Id}/hls/live.m3u8/head(headLivetvLiverecordingsByIdHlsLiveM3u8)`.
    internal func headLivetvLiverecordingsByIdHlsLiveM3u8(_ input: Operations.headLivetvLiverecordingsByIdHlsLiveM3u8.Input) async throws -> Operations.headLivetvLiverecordingsByIdHlsLiveM3u8.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headLivetvLiverecordingsByIdHlsLiveM3u8.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/LiveRecordings/{}/hls/live.m3u8",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a live tv channel
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/LiveStreamFiles/{Id}/hls/live.m3u8`.
    /// - Remark: Generated from `#/paths//LiveTv/LiveStreamFiles/{Id}/hls/live.m3u8/get(getLivetvLivestreamfilesByIdHlsLiveM3u8)`.
    internal func getLivetvLivestreamfilesByIdHlsLiveM3u8(_ input: Operations.getLivetvLivestreamfilesByIdHlsLiveM3u8.Input) async throws -> Operations.getLivetvLivestreamfilesByIdHlsLiveM3u8.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvLivestreamfilesByIdHlsLiveM3u8.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/LiveStreamFiles/{}/hls/live.m3u8",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a live tv channel
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /LiveTv/LiveStreamFiles/{Id}/hls/live.m3u8`.
    /// - Remark: Generated from `#/paths//LiveTv/LiveStreamFiles/{Id}/hls/live.m3u8/head(headLivetvLivestreamfilesByIdHlsLiveM3u8)`.
    internal func headLivetvLivestreamfilesByIdHlsLiveM3u8(_ input: Operations.headLivetvLivestreamfilesByIdHlsLiveM3u8.Input) async throws -> Operations.headLivetvLivestreamfilesByIdHlsLiveM3u8.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headLivetvLivestreamfilesByIdHlsLiveM3u8.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/LiveStreamFiles/{}/hls/live.m3u8",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a live tv channel
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/LiveStreamFiles/{Id}/hls/{Segment}`.
    /// - Remark: Generated from `#/paths//LiveTv/LiveStreamFiles/{Id}/hls/{Segment}/get(getLivetvLivestreamfilesByIdHlsBySegment)`.
    internal func getLivetvLivestreamfilesByIdHlsBySegment(_ input: Operations.getLivetvLivestreamfilesByIdHlsBySegment.Input) async throws -> Operations.getLivetvLivestreamfilesByIdHlsBySegment.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvLivestreamfilesByIdHlsBySegment.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/LiveStreamFiles/{}/hls/{}",
                    parameters: [
                        input.path.Id,
                        input.path.Segment
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a live tv channel
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /LiveTv/LiveStreamFiles/{Id}/hls/{Segment}`.
    /// - Remark: Generated from `#/paths//LiveTv/LiveStreamFiles/{Id}/hls/{Segment}/head(headLivetvLivestreamfilesByIdHlsBySegment)`.
    internal func headLivetvLivestreamfilesByIdHlsBySegment(_ input: Operations.headLivetvLivestreamfilesByIdHlsBySegment.Input) async throws -> Operations.headLivetvLivestreamfilesByIdHlsBySegment.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headLivetvLivestreamfilesByIdHlsBySegment.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/LiveStreamFiles/{}/hls/{}",
                    parameters: [
                        input.path.Id,
                        input.path.Segment
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a live recording
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /LiveTv/LiveRecordings/{Id}/hls/{Segment}`.
    /// - Remark: Generated from `#/paths//LiveTv/LiveRecordings/{Id}/hls/{Segment}/get(getLivetvLiverecordingsByIdHlsBySegment)`.
    internal func getLivetvLiverecordingsByIdHlsBySegment(_ input: Operations.getLivetvLiverecordingsByIdHlsBySegment.Input) async throws -> Operations.getLivetvLiverecordingsByIdHlsBySegment.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getLivetvLiverecordingsByIdHlsBySegment.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/LiveRecordings/{}/hls/{}",
                    parameters: [
                        input.path.Id,
                        input.path.Segment
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a live recording
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /LiveTv/LiveRecordings/{Id}/hls/{Segment}`.
    /// - Remark: Generated from `#/paths//LiveTv/LiveRecordings/{Id}/hls/{Segment}/head(headLivetvLiverecordingsByIdHlsBySegment)`.
    internal func headLivetvLiverecordingsByIdHlsBySegment(_ input: Operations.headLivetvLiverecordingsByIdHlsBySegment.Input) async throws -> Operations.headLivetvLiverecordingsByIdHlsBySegment.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headLivetvLiverecordingsByIdHlsBySegment.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/LiveRecordings/{}/hls/{}",
                    parameters: [
                        input.path.Id,
                        input.path.Segment
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Sets a channel disabled or not
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /LiveTv/Manage/Channels/{Id}/Disabled`.
    /// - Remark: Generated from `#/paths//LiveTv/Manage/Channels/{Id}/Disabled/post(postLivetvManageChannelsByIdDisabled)`.
    internal func postLivetvManageChannelsByIdDisabled(_ input: Operations.postLivetvManageChannelsByIdDisabled.Input) async throws -> Operations.postLivetvManageChannelsByIdDisabled.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLivetvManageChannelsByIdDisabled.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Manage/Channels/{}/Disabled",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postLivetvManageChannelsByIdDisabled.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_ChannelManagementInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Sets a channel sort index
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /LiveTv/Manage/Channels/{Id}/SortIndex`.
    /// - Remark: Generated from `#/paths//LiveTv/Manage/Channels/{Id}/SortIndex/post(postLivetvManageChannelsByIdSortindex)`.
    internal func postLivetvManageChannelsByIdSortindex(_ input: Operations.postLivetvManageChannelsByIdSortindex.Input) async throws -> Operations.postLivetvManageChannelsByIdSortindex.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postLivetvManageChannelsByIdSortindex.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/LiveTv/Manage/Channels/{}/SortIndex",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postLivetvManageChannelsByIdSortindex.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_ChannelManagementInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /MusicGenres/{Name}/Images/{Type}/{Index}`.
    /// - Remark: Generated from `#/paths//MusicGenres/{Name}/Images/{Type}/{Index}/get(getMusicgenresByNameImagesByTypeByIndex)`.
    internal func getMusicgenresByNameImagesByTypeByIndex(_ input: Operations.getMusicgenresByNameImagesByTypeByIndex.Input) async throws -> Operations.getMusicgenresByNameImagesByTypeByIndex.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getMusicgenresByNameImagesByTypeByIndex.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/MusicGenres/{}/Images/{}/{}",
                    parameters: [
                        input.path.Name,
                        input.path._Type,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /MusicGenres/{Name}/Images/{Type}/{Index}`.
    /// - Remark: Generated from `#/paths//MusicGenres/{Name}/Images/{Type}/{Index}/head(headMusicgenresByNameImagesByTypeByIndex)`.
    internal func headMusicgenresByNameImagesByTypeByIndex(_ input: Operations.headMusicgenresByNameImagesByTypeByIndex.Input) async throws -> Operations.headMusicgenresByNameImagesByTypeByIndex.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headMusicgenresByNameImagesByTypeByIndex.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/MusicGenres/{}/Images/{}/{}",
                    parameters: [
                        input.path.Name,
                        input.path._Type,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Persons/{Name}/Images/{Type}/{Index}`.
    /// - Remark: Generated from `#/paths//Persons/{Name}/Images/{Type}/{Index}/get(getPersonsByNameImagesByTypeByIndex)`.
    internal func getPersonsByNameImagesByTypeByIndex(_ input: Operations.getPersonsByNameImagesByTypeByIndex.Input) async throws -> Operations.getPersonsByNameImagesByTypeByIndex.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getPersonsByNameImagesByTypeByIndex.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Persons/{}/Images/{}/{}",
                    parameters: [
                        input.path.Name,
                        input.path._Type,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Persons/{Name}/Images/{Type}/{Index}`.
    /// - Remark: Generated from `#/paths//Persons/{Name}/Images/{Type}/{Index}/head(headPersonsByNameImagesByTypeByIndex)`.
    internal func headPersonsByNameImagesByTypeByIndex(_ input: Operations.headPersonsByNameImagesByTypeByIndex.Input) async throws -> Operations.headPersonsByNameImagesByTypeByIndex.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headPersonsByNameImagesByTypeByIndex.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Persons/{}/Images/{}/{}",
                    parameters: [
                        input.path.Name,
                        input.path._Type,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Removes an additional user from a session
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Sessions/{Id}/Users/{UserId}/Delete`.
    /// - Remark: Generated from `#/paths//Sessions/{Id}/Users/{UserId}/Delete/post(postSessionsByIdUsersByUseridDelete)`.
    internal func postSessionsByIdUsersByUseridDelete(_ input: Operations.postSessionsByIdUsersByUseridDelete.Input) async throws -> Operations.postSessionsByIdUsersByUseridDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postSessionsByIdUsersByUseridDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Sessions/{}/Users/{}/Delete",
                    parameters: [
                        input.path.Id,
                        input.path.UserId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Studios/{Name}/Images/{Type}/{Index}`.
    /// - Remark: Generated from `#/paths//Studios/{Name}/Images/{Type}/{Index}/get(getStudiosByNameImagesByTypeByIndex)`.
    internal func getStudiosByNameImagesByTypeByIndex(_ input: Operations.getStudiosByNameImagesByTypeByIndex.Input) async throws -> Operations.getStudiosByNameImagesByTypeByIndex.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getStudiosByNameImagesByTypeByIndex.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Studios/{}/Images/{}/{}",
                    parameters: [
                        input.path.Name,
                        input.path._Type,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Studios/{Name}/Images/{Type}/{Index}`.
    /// - Remark: Generated from `#/paths//Studios/{Name}/Images/{Type}/{Index}/head(headStudiosByNameImagesByTypeByIndex)`.
    internal func headStudiosByNameImagesByTypeByIndex(_ input: Operations.headStudiosByNameImagesByTypeByIndex.Input) async throws -> Operations.headStudiosByNameImagesByTypeByIndex.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headStudiosByNameImagesByTypeByIndex.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Studios/{}/Images/{}/{}",
                    parameters: [
                        input.path.Name,
                        input.path._Type,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Clears audio or subtitle track selections for a user
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{Id}/TrackSelections/{TrackType}/Delete`.
    /// - Remark: Generated from `#/paths//Users/{Id}/TrackSelections/{TrackType}/Delete/post(postUsersByIdTrackselectionsByTracktypeDelete)`.
    internal func postUsersByIdTrackselectionsByTracktypeDelete(_ input: Operations.postUsersByIdTrackselectionsByTracktypeDelete.Input) async throws -> Operations.postUsersByIdTrackselectionsByTracktypeDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByIdTrackselectionsByTracktypeDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/TrackSelections/{}/Delete",
                    parameters: [
                        input.path.Id,
                        input.path.TrackType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets special features for an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Users/{UserId}/Items/{Id}/SpecialFeatures`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/Items/{Id}/SpecialFeatures/get(getUsersByUseridItemsByIdSpecialfeatures)`.
    internal func getUsersByUseridItemsByIdSpecialfeatures(_ input: Operations.getUsersByUseridItemsByIdSpecialfeatures.Input) async throws -> Operations.getUsersByUseridItemsByIdSpecialfeatures.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUsersByUseridItemsByIdSpecialfeatures.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Items/{}/SpecialFeatures",
                    parameters: [
                        input.path.UserId,
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getUsersByUseridItemsByIdSpecialfeatures.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.BaseItemDto].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets local trailers for an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Users/{UserId}/Items/{Id}/LocalTrailers`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/Items/{Id}/LocalTrailers/get(getUsersByUseridItemsByIdLocaltrailers)`.
    internal func getUsersByUseridItemsByIdLocaltrailers(_ input: Operations.getUsersByUseridItemsByIdLocaltrailers.Input) async throws -> Operations.getUsersByUseridItemsByIdLocaltrailers.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUsersByUseridItemsByIdLocaltrailers.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Items/{}/LocalTrailers",
                    parameters: [
                        input.path.UserId,
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getUsersByUseridItemsByIdLocaltrailers.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.BaseItemDto].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets intros to play before the main media item plays
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Users/{UserId}/Items/{Id}/Intros`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/Items/{Id}/Intros/get(getUsersByUseridItemsByIdIntros)`.
    internal func getUsersByUseridItemsByIdIntros(_ input: Operations.getUsersByUseridItemsByIdIntros.Input) async throws -> Operations.getUsersByUseridItemsByIdIntros.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUsersByUseridItemsByIdIntros.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Items/{}/Intros",
                    parameters: [
                        input.path.UserId,
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Fields",
                    value: input.query.Fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImages",
                    value: input.query.EnableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ImageTypeLimit",
                    value: input.query.ImageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageTypes",
                    value: input.query.EnableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableUserData",
                    value: input.query.EnableUserData
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getUsersByUseridItemsByIdIntros.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.QueryResult_BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Unmarks an item as a favorite
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{UserId}/FavoriteItems/{Id}/Delete`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/FavoriteItems/{Id}/Delete/post(postUsersByUseridFavoriteitemsByIdDelete)`.
    internal func postUsersByUseridFavoriteitemsByIdDelete(_ input: Operations.postUsersByUseridFavoriteitemsByIdDelete.Input) async throws -> Operations.postUsersByUseridFavoriteitemsByIdDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByUseridFavoriteitemsByIdDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/FavoriteItems/{}/Delete",
                    parameters: [
                        input.path.UserId,
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postUsersByUseridFavoriteitemsByIdDelete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserItemDataDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates a user's rating for an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{UserId}/Items/{Id}/Rating`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/Items/{Id}/Rating/post(postUsersByUseridItemsByIdRating)`.
    internal func postUsersByUseridItemsByIdRating(_ input: Operations.postUsersByUseridItemsByIdRating.Input) async throws -> Operations.postUsersByUseridItemsByIdRating.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByUseridItemsByIdRating.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Items/{}/Rating",
                    parameters: [
                        input.path.UserId,
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Likes",
                    value: input.query.Likes
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postUsersByUseridItemsByIdRating.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserItemDataDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deletes a user's saved personal rating for an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `DELETE /Users/{UserId}/Items/{Id}/Rating`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/Items/{Id}/Rating/delete(deleteUsersByUseridItemsByIdRating)`.
    internal func deleteUsersByUseridItemsByIdRating(_ input: Operations.deleteUsersByUseridItemsByIdRating.Input) async throws -> Operations.deleteUsersByUseridItemsByIdRating.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteUsersByUseridItemsByIdRating.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Items/{}/Rating",
                    parameters: [
                        input.path.UserId,
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.deleteUsersByUseridItemsByIdRating.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserItemDataDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates a user's hide from resume for an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{UserId}/Items/{Id}/HideFromResume`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/Items/{Id}/HideFromResume/post(postUsersByUseridItemsByIdHidefromresume)`.
    internal func postUsersByUseridItemsByIdHidefromresume(_ input: Operations.postUsersByUseridItemsByIdHidefromresume.Input) async throws -> Operations.postUsersByUseridItemsByIdHidefromresume.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByUseridItemsByIdHidefromresume.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Items/{}/HideFromResume",
                    parameters: [
                        input.path.UserId,
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Hide",
                    value: input.query.Hide
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postUsersByUseridItemsByIdHidefromresume.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserItemDataDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Users/{Id}/Images/{Type}/{Index}`.
    /// - Remark: Generated from `#/paths//Users/{Id}/Images/{Type}/{Index}/get(getUsersByIdImagesByTypeByIndex)`.
    internal func getUsersByIdImagesByTypeByIndex(_ input: Operations.getUsersByIdImagesByTypeByIndex.Input) async throws -> Operations.getUsersByIdImagesByTypeByIndex.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUsersByIdImagesByTypeByIndex.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Images/{}/{}",
                    parameters: [
                        input.path.Id,
                        input.path._Type,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Uploads an image for an item, must be base64 encoded.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{Id}/Images/{Type}/{Index}`.
    /// - Remark: Generated from `#/paths//Users/{Id}/Images/{Type}/{Index}/post(postUsersByIdImagesByTypeByIndex)`.
    internal func postUsersByIdImagesByTypeByIndex(_ input: Operations.postUsersByIdImagesByTypeByIndex.Input) async throws -> Operations.postUsersByIdImagesByTypeByIndex.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByIdImagesByTypeByIndex.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Images/{}/{}",
                    parameters: [
                        input.path.Id,
                        input.path._Type,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .binary(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/octet-stream"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `DELETE /Users/{Id}/Images/{Type}/{Index}`.
    /// - Remark: Generated from `#/paths//Users/{Id}/Images/{Type}/{Index}/delete(deleteUsersByIdImagesByTypeByIndex)`.
    internal func deleteUsersByIdImagesByTypeByIndex(_ input: Operations.deleteUsersByIdImagesByTypeByIndex.Input) async throws -> Operations.deleteUsersByIdImagesByTypeByIndex.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteUsersByIdImagesByTypeByIndex.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Images/{}/{}",
                    parameters: [
                        input.path.Id,
                        input.path._Type,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Users/{Id}/Images/{Type}/{Index}`.
    /// - Remark: Generated from `#/paths//Users/{Id}/Images/{Type}/{Index}/head(headUsersByIdImagesByTypeByIndex)`.
    internal func headUsersByIdImagesByTypeByIndex(_ input: Operations.headUsersByIdImagesByTypeByIndex.Input) async throws -> Operations.headUsersByIdImagesByTypeByIndex.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headUsersByIdImagesByTypeByIndex.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Images/{}/{}",
                    parameters: [
                        input.path.Id,
                        input.path._Type,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxWidth",
                    value: input.query.MaxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MaxHeight",
                    value: input.query.MaxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Width",
                    value: input.query.Width
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Height",
                    value: input.query.Height
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Quality",
                    value: input.query.Quality
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Tag",
                    value: input.query.Tag
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CropWhitespace",
                    value: input.query.CropWhitespace
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EnableImageEnhancers",
                    value: input.query.EnableImageEnhancers
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Format",
                    value: input.query.Format
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "BackgroundColor",
                    value: input.query.BackgroundColor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "ForegroundLayer",
                    value: input.query.ForegroundLayer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AutoOrient",
                    value: input.query.AutoOrient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "KeepAnimation",
                    value: input.query.KeepAnimation
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{Id}/Images/{Type}/Delete`.
    /// - Remark: Generated from `#/paths//Users/{Id}/Images/{Type}/Delete/post(postUsersByIdImagesByTypeDelete)`.
    internal func postUsersByIdImagesByTypeDelete(_ input: Operations.postUsersByIdImagesByTypeDelete.Input) async throws -> Operations.postUsersByIdImagesByTypeDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByIdImagesByTypeDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Images/{}/Delete",
                    parameters: [
                        input.path.Id,
                        input.path._Type
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Index",
                    value: input.query.Index
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates userdata for an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{UserId}/Items/{ItemId}/UserData`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/Items/{ItemId}/UserData/post(postUsersByUseridItemsByItemidUserdata)`.
    internal func postUsersByUseridItemsByItemidUserdata(_ input: Operations.postUsersByUseridItemsByItemidUserdata.Input) async throws -> Operations.postUsersByUseridItemsByItemidUserdata.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByUseridItemsByItemidUserdata.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Items/{}/UserData",
                    parameters: [
                        input.path.UserId,
                        input.path.ItemId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Reports a user's playback progress
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{UserId}/PlayingItems/{Id}/Progress`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/PlayingItems/{Id}/Progress/post(postUsersByUseridPlayingitemsByIdProgress)`.
    internal func postUsersByUseridPlayingitemsByIdProgress(_ input: Operations.postUsersByUseridPlayingitemsByIdProgress.Input) async throws -> Operations.postUsersByUseridPlayingitemsByIdProgress.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByUseridPlayingitemsByIdProgress.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/PlayingItems/{}/Progress",
                    parameters: [
                        input.path.UserId,
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MediaSourceId",
                    value: input.query.MediaSourceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PositionTicks",
                    value: input.query.PositionTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsPaused",
                    value: input.query.IsPaused
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "IsMuted",
                    value: input.query.IsMuted
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "AudioStreamIndex",
                    value: input.query.AudioStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleStreamIndex",
                    value: input.query.SubtitleStreamIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "VolumeLevel",
                    value: input.query.VolumeLevel
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PlayMethod",
                    value: input.query.PlayMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "LiveStreamId",
                    value: input.query.LiveStreamId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PlaySessionId",
                    value: input.query.PlaySessionId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "RepeatMode",
                    value: input.query.RepeatMode
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "SubtitleOffset",
                    value: input.query.SubtitleOffset
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PlaybackRate",
                    value: input.query.PlaybackRate
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Reports that a user has stopped playing an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{UserId}/PlayingItems/{Id}/Delete`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/PlayingItems/{Id}/Delete/post(postUsersByUseridPlayingitemsByIdDelete)`.
    internal func postUsersByUseridPlayingitemsByIdDelete(_ input: Operations.postUsersByUseridPlayingitemsByIdDelete.Input) async throws -> Operations.postUsersByUseridPlayingitemsByIdDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByUseridPlayingitemsByIdDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/PlayingItems/{}/Delete",
                    parameters: [
                        input.path.UserId,
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MediaSourceId",
                    value: input.query.MediaSourceId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NextMediaType",
                    value: input.query.NextMediaType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PositionTicks",
                    value: input.query.PositionTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "LiveStreamId",
                    value: input.query.LiveStreamId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "PlaySessionId",
                    value: input.query.PlaySessionId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Marks an item as unplayed
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{UserId}/PlayedItems/{Id}/Delete`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/PlayedItems/{Id}/Delete/post(postUsersByUseridPlayeditemsByIdDelete)`.
    internal func postUsersByUseridPlayeditemsByIdDelete(_ input: Operations.postUsersByUseridPlayeditemsByIdDelete.Input) async throws -> Operations.postUsersByUseridPlayeditemsByIdDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByUseridPlayeditemsByIdDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/PlayedItems/{}/Delete",
                    parameters: [
                        input.path.UserId,
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postUsersByUseridPlayeditemsByIdDelete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserItemDataDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Removes a Connect link for a user
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Users/{Id}/Connect/Link/Delete`.
    /// - Remark: Generated from `#/paths//Users/{Id}/Connect/Link/Delete/post(postUsersByIdConnectLinkDelete)`.
    internal func postUsersByIdConnectLinkDelete(_ input: Operations.postUsersByIdConnectLinkDelete.Input) async throws -> Operations.postUsersByIdConnectLinkDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByIdConnectLinkDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Connect/Link/Delete",
                    parameters: [
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deletes an external subtitle file
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Videos/{Id}/Subtitles/{Index}/Delete`.
    /// - Remark: Generated from `#/paths//Videos/{Id}/Subtitles/{Index}/Delete/post(postVideosByIdSubtitlesByIndexDelete)`.
    internal func postVideosByIdSubtitlesByIndexDelete(_ input: Operations.postVideosByIdSubtitlesByIndexDelete.Input) async throws -> Operations.postVideosByIdSubtitlesByIndexDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postVideosByIdSubtitlesByIndexDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/{}/Subtitles/{}/Delete",
                    parameters: [
                        input.path.Id,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "MediaSourceId",
                    value: input.query.MediaSourceId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Videos/{Id}/hls1/{PlaylistId}/{SegmentId}.{SegmentContainer}`.
    /// - Remark: Generated from `#/paths//Videos/{Id}/hls1/{PlaylistId}/{SegmentId}.{SegmentContainer}/get(getVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainer)`.
    internal func getVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainer(_ input: Operations.getVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainer.Input) async throws -> Operations.getVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainer.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainer.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/{}/hls1/{}/{}.{}",
                    parameters: [
                        input.path.Id,
                        input.path.PlaylistId,
                        input.path.SegmentId,
                        input.path.SegmentContainer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Videos/{Id}/hls1/{PlaylistId}/{SegmentId}.{SegmentContainer}`.
    /// - Remark: Generated from `#/paths//Videos/{Id}/hls1/{PlaylistId}/{SegmentId}.{SegmentContainer}/head(headVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainer)`.
    internal func headVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainer(_ input: Operations.headVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainer.Input) async throws -> Operations.headVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainer.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainer.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/{}/hls1/{}/{}.{}",
                    parameters: [
                        input.path.Id,
                        input.path.PlaylistId,
                        input.path.SegmentId,
                        input.path.SegmentContainer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Videos/{Id}/hls/{PlaylistId}/{SegmentId}.{SegmentContainer}`.
    /// - Remark: Generated from `#/paths//Videos/{Id}/hls/{PlaylistId}/{SegmentId}.{SegmentContainer}/get(getVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainer)`.
    internal func getVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainer(_ input: Operations.getVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainer.Input) async throws -> Operations.getVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainer.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainer.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/{}/hls/{}/{}.{}",
                    parameters: [
                        input.path.Id,
                        input.path.PlaylistId,
                        input.path.SegmentId,
                        input.path.SegmentContainer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets subtitles in a specified format.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Items/{Id}/{MediaSourceId}/Subtitles/{Index}/Stream.{Format}`.
    /// - Remark: Generated from `#/paths//Items/{Id}/{MediaSourceId}/Subtitles/{Index}/Stream.{Format}/get(getItemsByIdByMediasourceidSubtitlesByIndexStreamByFormat)`.
    internal func getItemsByIdByMediasourceidSubtitlesByIndexStreamByFormat(_ input: Operations.getItemsByIdByMediasourceidSubtitlesByIndexStreamByFormat.Input) async throws -> Operations.getItemsByIdByMediasourceidSubtitlesByIndexStreamByFormat.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsByIdByMediasourceidSubtitlesByIndexStreamByFormat.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/{}/Subtitles/{}/Stream.{}",
                    parameters: [
                        input.path.Id,
                        input.path.MediaSourceId,
                        input.path.Index,
                        input.path.Format
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartPositionTicks",
                    value: input.query.StartPositionTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EndPositionTicks",
                    value: input.query.EndPositionTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets subtitles in a specified format.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Items/{Id}/{MediaSourceId}/Subtitles/{Index}/Stream.{Format}`.
    /// - Remark: Generated from `#/paths//Items/{Id}/{MediaSourceId}/Subtitles/{Index}/Stream.{Format}/head(headItemsByIdByMediasourceidSubtitlesByIndexStreamByFormat)`.
    internal func headItemsByIdByMediasourceidSubtitlesByIndexStreamByFormat(_ input: Operations.headItemsByIdByMediasourceidSubtitlesByIndexStreamByFormat.Input) async throws -> Operations.headItemsByIdByMediasourceidSubtitlesByIndexStreamByFormat.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headItemsByIdByMediasourceidSubtitlesByIndexStreamByFormat.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/{}/Subtitles/{}/Stream.{}",
                    parameters: [
                        input.path.Id,
                        input.path.MediaSourceId,
                        input.path.Index,
                        input.path.Format
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartPositionTicks",
                    value: input.query.StartPositionTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EndPositionTicks",
                    value: input.query.EndPositionTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Items/{Id}/Images/{Type}/{Index}/Delete`.
    /// - Remark: Generated from `#/paths//Items/{Id}/Images/{Type}/{Index}/Delete/post(postItemsByIdImagesByTypeByIndexDelete)`.
    internal func postItemsByIdImagesByTypeByIndexDelete(_ input: Operations.postItemsByIdImagesByTypeByIndexDelete.Input) async throws -> Operations.postItemsByIdImagesByTypeByIndexDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsByIdImagesByTypeByIndexDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/Images/{}/{}/Delete",
                    parameters: [
                        input.path.Id,
                        input.path._Type,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates the index for an item image
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Items/{Id}/Images/{Type}/{Index}/Index`.
    /// - Remark: Generated from `#/paths//Items/{Id}/Images/{Type}/{Index}/Index/post(postItemsByIdImagesByTypeByIndexIndex)`.
    internal func postItemsByIdImagesByTypeByIndexIndex(_ input: Operations.postItemsByIdImagesByTypeByIndexIndex.Input) async throws -> Operations.postItemsByIdImagesByTypeByIndexIndex.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsByIdImagesByTypeByIndexIndex.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/Images/{}/{}/Index",
                    parameters: [
                        input.path.Id,
                        input.path._Type,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "NewIndex",
                    value: input.query.NewIndex
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Updates the index for an item image
    ///
    /// Requires authentication as administrator
    ///
    /// - Remark: HTTP `POST /Items/{Id}/Images/{Type}/{Index}/Url`.
    /// - Remark: Generated from `#/paths//Items/{Id}/Images/{Type}/{Index}/Url/post(postItemsByIdImagesByTypeByIndexUrl)`.
    internal func postItemsByIdImagesByTypeByIndexUrl(_ input: Operations.postItemsByIdImagesByTypeByIndexUrl.Input) async throws -> Operations.postItemsByIdImagesByTypeByIndexUrl.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postItemsByIdImagesByTypeByIndexUrl.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/Images/{}/{}/Url",
                    parameters: [
                        input.path.Id,
                        input.path._Type,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "Url",
                    value: input.query.Url
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Moves a playlist item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Playlists/{Id}/Items/{ItemId}/Move/{NewIndex}`.
    /// - Remark: Generated from `#/paths//Playlists/{Id}/Items/{ItemId}/Move/{NewIndex}/post(postPlaylistsByIdItemsByItemidMoveByNewindex)`.
    internal func postPlaylistsByIdItemsByItemidMoveByNewindex(_ input: Operations.postPlaylistsByIdItemsByItemidMoveByNewindex.Input) async throws -> Operations.postPlaylistsByIdItemsByItemidMoveByNewindex.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postPlaylistsByIdItemsByItemidMoveByNewindex.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Playlists/{}/Items/{}/Move/{}",
                    parameters: [
                        input.path.Id,
                        input.path.ItemId,
                        input.path.NewIndex
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deletes a user's saved personal rating for an item
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{UserId}/Items/{Id}/Rating/Delete`.
    /// - Remark: Generated from `#/paths//Users/{UserId}/Items/{Id}/Rating/Delete/post(postUsersByUseridItemsByIdRatingDelete)`.
    internal func postUsersByUseridItemsByIdRatingDelete(_ input: Operations.postUsersByUseridItemsByIdRatingDelete.Input) async throws -> Operations.postUsersByUseridItemsByIdRatingDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByUseridItemsByIdRatingDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Items/{}/Rating/Delete",
                    parameters: [
                        input.path.UserId,
                        input.path.Id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postUsersByUseridItemsByIdRatingDelete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserItemDataDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `POST /Users/{Id}/Images/{Type}/{Index}/Delete`.
    /// - Remark: Generated from `#/paths//Users/{Id}/Images/{Type}/{Index}/Delete/post(postUsersByIdImagesByTypeByIndexDelete)`.
    internal func postUsersByIdImagesByTypeByIndexDelete(_ input: Operations.postUsersByIdImagesByTypeByIndexDelete.Input) async throws -> Operations.postUsersByIdImagesByTypeByIndexDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postUsersByIdImagesByTypeByIndexDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/{}/Images/{}/{}/Delete",
                    parameters: [
                        input.path.Id,
                        input.path._Type,
                        input.path.Index
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets subtitles in a specified format.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Videos/{Id}/{MediaSourceId}/Subtitles/{Index}/Stream.{Format}`.
    /// - Remark: Generated from `#/paths//Videos/{Id}/{MediaSourceId}/Subtitles/{Index}/Stream.{Format}/get(getVideosByIdByMediasourceidSubtitlesByIndexStreamByFormat)`.
    internal func getVideosByIdByMediasourceidSubtitlesByIndexStreamByFormat(_ input: Operations.getVideosByIdByMediasourceidSubtitlesByIndexStreamByFormat.Input) async throws -> Operations.getVideosByIdByMediasourceidSubtitlesByIndexStreamByFormat.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getVideosByIdByMediasourceidSubtitlesByIndexStreamByFormat.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/{}/{}/Subtitles/{}/Stream.{}",
                    parameters: [
                        input.path.Id,
                        input.path.MediaSourceId,
                        input.path.Index,
                        input.path.Format
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartPositionTicks",
                    value: input.query.StartPositionTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EndPositionTicks",
                    value: input.query.EndPositionTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets subtitles in a specified format.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Videos/{Id}/{MediaSourceId}/Subtitles/{Index}/Stream.{Format}`.
    /// - Remark: Generated from `#/paths//Videos/{Id}/{MediaSourceId}/Subtitles/{Index}/Stream.{Format}/head(headVideosByIdByMediasourceidSubtitlesByIndexStreamByFormat)`.
    internal func headVideosByIdByMediasourceidSubtitlesByIndexStreamByFormat(_ input: Operations.headVideosByIdByMediasourceidSubtitlesByIndexStreamByFormat.Input) async throws -> Operations.headVideosByIdByMediasourceidSubtitlesByIndexStreamByFormat.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headVideosByIdByMediasourceidSubtitlesByIndexStreamByFormat.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/{}/{}/Subtitles/{}/Stream.{}",
                    parameters: [
                        input.path.Id,
                        input.path.MediaSourceId,
                        input.path.Index,
                        input.path.Format
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "StartPositionTicks",
                    value: input.query.StartPositionTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EndPositionTicks",
                    value: input.query.EndPositionTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets subtitles in a specified format.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Items/{Id}/{MediaSourceId}/Subtitles/{Index}/{StartPositionTicks}/Stream.{Format}`.
    /// - Remark: Generated from `#/paths//Items/{Id}/{MediaSourceId}/Subtitles/{Index}/{StartPositionTicks}/Stream.{Format}/get(getItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormat)`.
    internal func getItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormat(_ input: Operations.getItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormat.Input) async throws -> Operations.getItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormat.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormat.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/{}/Subtitles/{}/{}/Stream.{}",
                    parameters: [
                        input.path.Id,
                        input.path.MediaSourceId,
                        input.path.Index,
                        input.path.StartPositionTicks,
                        input.path.Format
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EndPositionTicks",
                    value: input.query.EndPositionTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets subtitles in a specified format.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Items/{Id}/{MediaSourceId}/Subtitles/{Index}/{StartPositionTicks}/Stream.{Format}`.
    /// - Remark: Generated from `#/paths//Items/{Id}/{MediaSourceId}/Subtitles/{Index}/{StartPositionTicks}/Stream.{Format}/head(headItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormat)`.
    internal func headItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormat(_ input: Operations.headItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormat.Input) async throws -> Operations.headItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormat.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormat.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items/{}/{}/Subtitles/{}/{}/Stream.{}",
                    parameters: [
                        input.path.Id,
                        input.path.MediaSourceId,
                        input.path.Index,
                        input.path.StartPositionTicks,
                        input.path.Format
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EndPositionTicks",
                    value: input.query.EndPositionTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets subtitles in a specified format.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `GET /Videos/{Id}/{MediaSourceId}/Subtitles/{Index}/{StartPositionTicks}/Stream.{Format}`.
    /// - Remark: Generated from `#/paths//Videos/{Id}/{MediaSourceId}/Subtitles/{Index}/{StartPositionTicks}/Stream.{Format}/get(getVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormat)`.
    internal func getVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormat(_ input: Operations.getVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormat.Input) async throws -> Operations.getVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormat.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormat.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/{}/{}/Subtitles/{}/{}/Stream.{}",
                    parameters: [
                        input.path.Id,
                        input.path.MediaSourceId,
                        input.path.Index,
                        input.path.StartPositionTicks,
                        input.path.Format
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EndPositionTicks",
                    value: input.query.EndPositionTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets subtitles in a specified format.
    ///
    /// Requires authentication as user
    ///
    /// - Remark: HTTP `HEAD /Videos/{Id}/{MediaSourceId}/Subtitles/{Index}/{StartPositionTicks}/Stream.{Format}`.
    /// - Remark: Generated from `#/paths//Videos/{Id}/{MediaSourceId}/Subtitles/{Index}/{StartPositionTicks}/Stream.{Format}/head(headVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormat)`.
    internal func headVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormat(_ input: Operations.headVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormat.Input) async throws -> Operations.headVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormat.Output {
        try await client.send(
            input: input,
            forOperation: Operations.headVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormat.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Videos/{}/{}/Subtitles/{}/{}/Stream.{}",
                    parameters: [
                        input.path.Id,
                        input.path.MediaSourceId,
                        input.path.Index,
                        input.path.StartPositionTicks,
                        input.path.Format
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .head
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "EndPositionTicks",
                    value: input.query.EndPositionTicks
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "CopyTimestamps",
                    value: input.query.CopyTimestamps
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                case 404:
                    return .notFound(.init())
                case 500:
                    return .internalServerError(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
}
